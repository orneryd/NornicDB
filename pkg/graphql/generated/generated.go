// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/orneryd/nornicdb/pkg/graphql/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CypherResult() CypherResultResolver
	Mutation() MutationResolver
	Node() NodeResolver
	Query() QueryResolver
	Relationship() RelationshipResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	BulkCreateResult struct {
		Created func(childComplexity int) int
		Errors  func(childComplexity int) int
		Skipped func(childComplexity int) int
	}

	BulkDeleteResult struct {
		Deleted  func(childComplexity int) int
		NotFound func(childComplexity int) int
	}

	CypherResult struct {
		Columns         func(childComplexity int) int
		ExecutionTimeMs func(childComplexity int) int
		RowCount        func(childComplexity int) int
		Rows            func(childComplexity int) int
		Stats           func(childComplexity int) int
	}

	CypherStats struct {
		ContainsUpdates      func(childComplexity int) int
		LabelsAdded          func(childComplexity int) int
		LabelsRemoved        func(childComplexity int) int
		NodesCreated         func(childComplexity int) int
		NodesDeleted         func(childComplexity int) int
		PropertiesSet        func(childComplexity int) int
		RelationshipsCreated func(childComplexity int) int
		RelationshipsDeleted func(childComplexity int) int
	}

	DatabaseStats struct {
		EmbeddedNodeCount func(childComplexity int) int
		Labels            func(childComplexity int) int
		MemoryUsageBytes  func(childComplexity int) int
		NodeCount         func(childComplexity int) int
		RelationshipCount func(childComplexity int) int
		RelationshipTypes func(childComplexity int) int
		UptimeSeconds     func(childComplexity int) int
	}

	DecayResult struct {
		AverageDecayScore func(childComplexity int) int
		NodesDecayed      func(childComplexity int) int
		NodesProcessed    func(childComplexity int) int
	}

	EmbeddingStatus struct {
		Embedded      func(childComplexity int) int
		Pending       func(childComplexity int) int
		Total         func(childComplexity int) int
		WorkerRunning func(childComplexity int) int
	}

	GraphSchema struct {
		Constraints              func(childComplexity int) int
		NodeLabels               func(childComplexity int) int
		NodePropertyKeys         func(childComplexity int) int
		RelationshipPropertyKeys func(childComplexity int) int
		RelationshipTypes        func(childComplexity int) int
	}

	LabelStats struct {
		Count func(childComplexity int) int
		Label func(childComplexity int) int
	}

	Mutation struct {
		BulkCreateNodes         func(childComplexity int, input models.BulkCreateNodesInput) int
		BulkCreateRelationships func(childComplexity int, input models.BulkCreateRelationshipsInput) int
		BulkDeleteNodes         func(childComplexity int, ids []string) int
		BulkDeleteRelationships func(childComplexity int, ids []string) int
		ClearAll                func(childComplexity int, confirmPhrase string) int
		CreateNode              func(childComplexity int, input models.CreateNodeInput) int
		CreateRelationship      func(childComplexity int, input models.CreateRelationshipInput) int
		DeleteNode              func(childComplexity int, id string) int
		DeleteRelationship      func(childComplexity int, id string) int
		ExecuteCypher           func(childComplexity int, input models.CypherInput) int
		MergeNode               func(childComplexity int, labels []string, matchProperties models.JSON, setProperties models.JSON) int
		MergeRelationship       func(childComplexity int, startNodeID string, endNodeID string, typeArg string, properties models.JSON) int
		RebuildSearchIndex      func(childComplexity int) int
		RunDecay                func(childComplexity int) int
		TriggerEmbedding        func(childComplexity int, regenerate *bool) int
		UpdateNode              func(childComplexity int, input models.UpdateNodeInput) int
		UpdateRelationship      func(childComplexity int, input models.UpdateRelationshipInput) int
	}

	Node struct {
		AccessCount         func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		DecayScore          func(childComplexity int) int
		EmbeddingDimensions func(childComplexity int) int
		HasEmbedding        func(childComplexity int) int
		ID                  func(childComplexity int) int
		Incoming            func(childComplexity int, types []string, limit *int) int
		InternalID          func(childComplexity int) int
		Labels              func(childComplexity int) int
		LastAccessed        func(childComplexity int) int
		Neighbors           func(childComplexity int, direction *models.RelationshipDirection, relationshipTypes []string, labels []string, limit *int) int
		Outgoing            func(childComplexity int, types []string, limit *int) int
		Properties          func(childComplexity int) int
		Relationships       func(childComplexity int, types []string, direction *models.RelationshipDirection, limit *int) int
		Similar             func(childComplexity int, limit *int, threshold *float64) int
		UpdatedAt           func(childComplexity int) int
	}

	Query struct {
		AllNodes             func(childComplexity int, labels []string, limit *int, offset *int) int
		AllPaths             func(childComplexity int, startNodeID string, endNodeID string, maxDepth *int, limit *int) int
		AllRelationships     func(childComplexity int, types []string, limit *int, offset *int) int
		Cypher               func(childComplexity int, input models.CypherInput) int
		Labels               func(childComplexity int) int
		Neighborhood         func(childComplexity int, nodeID string, depth *int, relationshipTypes []string, labels []string, limit *int) int
		Node                 func(childComplexity int, id string) int
		NodeCount            func(childComplexity int, label *string) int
		Nodes                func(childComplexity int, ids []string) int
		NodesByLabel         func(childComplexity int, label string, limit *int, offset *int) int
		Relationship         func(childComplexity int, id string) int
		RelationshipCount    func(childComplexity int, typeArg *string) int
		RelationshipTypes    func(childComplexity int) int
		RelationshipsBetween func(childComplexity int, startNodeID string, endNodeID string) int
		RelationshipsByType  func(childComplexity int, typeArg string, limit *int, offset *int) int
		Schema               func(childComplexity int) int
		Search               func(childComplexity int, query string, options *models.SearchOptions) int
		SearchByProperty     func(childComplexity int, key string, value models.JSON, labels []string, limit *int) int
		ShortestPath         func(childComplexity int, startNodeID string, endNodeID string, maxDepth *int, relationshipTypes []string) int
		Similar              func(childComplexity int, nodeID string, limit *int, threshold *float64) int
		Stats                func(childComplexity int) int
	}

	Relationship struct {
		AutoGenerated func(childComplexity int) int
		Confidence    func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		EndNode       func(childComplexity int) int
		ID            func(childComplexity int) int
		InternalID    func(childComplexity int) int
		Properties    func(childComplexity int) int
		StartNode     func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	RelationshipTypeStats struct {
		Count func(childComplexity int) int
		Type  func(childComplexity int) int
	}

	SchemaConstraint struct {
		EntityType    func(childComplexity int) int
		LabelsOrTypes func(childComplexity int) int
		Name          func(childComplexity int) int
		Properties    func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	SearchResponse struct {
		BM25SearchUsed   func(childComplexity int) int
		ExecutionTimeMs  func(childComplexity int) int
		Method           func(childComplexity int) int
		Results          func(childComplexity int) int
		TotalCount       func(childComplexity int) int
		VectorSearchUsed func(childComplexity int) int
	}

	SearchResult struct {
		BM25Rank    func(childComplexity int) int
		BM25Score   func(childComplexity int) int
		FoundBy     func(childComplexity int) int
		Node        func(childComplexity int) int
		RRFScore    func(childComplexity int) int
		Score       func(childComplexity int) int
		VectorRank  func(childComplexity int) int
		VectorScore func(childComplexity int) int
	}

	SimilarNode struct {
		Node       func(childComplexity int) int
		Similarity func(childComplexity int) int
	}

	Subgraph struct {
		Nodes         func(childComplexity int) int
		Relationships func(childComplexity int) int
	}

	Subscription struct {
		NodeCreated         func(childComplexity int, labels []string) int
		NodeDeleted         func(childComplexity int, labels []string) int
		NodeUpdated         func(childComplexity int, id *string, labels []string) int
		RelationshipCreated func(childComplexity int, types []string) int
		RelationshipDeleted func(childComplexity int, types []string) int
		RelationshipUpdated func(childComplexity int, id *string, types []string) int
		SearchStream        func(childComplexity int, query string, options *models.SearchOptions) int
	}
}

type CypherResultResolver interface {
	Rows(ctx context.Context, obj *models.CypherResult) ([][]models.JSON, error)
}
type MutationResolver interface {
	CreateNode(ctx context.Context, input models.CreateNodeInput) (*models.Node, error)
	UpdateNode(ctx context.Context, input models.UpdateNodeInput) (*models.Node, error)
	DeleteNode(ctx context.Context, id string) (bool, error)
	BulkCreateNodes(ctx context.Context, input models.BulkCreateNodesInput) (*models.BulkCreateResult, error)
	BulkDeleteNodes(ctx context.Context, ids []string) (*models.BulkDeleteResult, error)
	MergeNode(ctx context.Context, labels []string, matchProperties models.JSON, setProperties models.JSON) (*models.Node, error)
	CreateRelationship(ctx context.Context, input models.CreateRelationshipInput) (*models.Relationship, error)
	UpdateRelationship(ctx context.Context, input models.UpdateRelationshipInput) (*models.Relationship, error)
	DeleteRelationship(ctx context.Context, id string) (bool, error)
	BulkCreateRelationships(ctx context.Context, input models.BulkCreateRelationshipsInput) (*models.BulkCreateResult, error)
	BulkDeleteRelationships(ctx context.Context, ids []string) (*models.BulkDeleteResult, error)
	MergeRelationship(ctx context.Context, startNodeID string, endNodeID string, typeArg string, properties models.JSON) (*models.Relationship, error)
	ExecuteCypher(ctx context.Context, input models.CypherInput) (*models.CypherResult, error)
	TriggerEmbedding(ctx context.Context, regenerate *bool) (*models.EmbeddingStatus, error)
	RebuildSearchIndex(ctx context.Context) (bool, error)
	RunDecay(ctx context.Context) (*models.DecayResult, error)
	ClearAll(ctx context.Context, confirmPhrase string) (bool, error)
}
type NodeResolver interface {
	Relationships(ctx context.Context, obj *models.Node, types []string, direction *models.RelationshipDirection, limit *int) ([]models.Relationship, error)
	Outgoing(ctx context.Context, obj *models.Node, types []string, limit *int) ([]models.Relationship, error)
	Incoming(ctx context.Context, obj *models.Node, types []string, limit *int) ([]models.Relationship, error)
	Neighbors(ctx context.Context, obj *models.Node, direction *models.RelationshipDirection, relationshipTypes []string, labels []string, limit *int) ([]models.Node, error)
	Similar(ctx context.Context, obj *models.Node, limit *int, threshold *float64) ([]models.SimilarNode, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id string) (*models.Node, error)
	Nodes(ctx context.Context, ids []string) ([]models.Node, error)
	AllNodes(ctx context.Context, labels []string, limit *int, offset *int) ([]models.Node, error)
	NodesByLabel(ctx context.Context, label string, limit *int, offset *int) ([]models.Node, error)
	NodeCount(ctx context.Context, label *string) (int, error)
	Relationship(ctx context.Context, id string) (*models.Relationship, error)
	AllRelationships(ctx context.Context, types []string, limit *int, offset *int) ([]models.Relationship, error)
	RelationshipsByType(ctx context.Context, typeArg string, limit *int, offset *int) ([]models.Relationship, error)
	RelationshipsBetween(ctx context.Context, startNodeID string, endNodeID string) ([]models.Relationship, error)
	RelationshipCount(ctx context.Context, typeArg *string) (int, error)
	Search(ctx context.Context, query string, options *models.SearchOptions) (*models.SearchResponse, error)
	Similar(ctx context.Context, nodeID string, limit *int, threshold *float64) ([]models.SimilarNode, error)
	SearchByProperty(ctx context.Context, key string, value models.JSON, labels []string, limit *int) ([]models.Node, error)
	Cypher(ctx context.Context, input models.CypherInput) (*models.CypherResult, error)
	Stats(ctx context.Context) (*models.DatabaseStats, error)
	Schema(ctx context.Context) (*models.GraphSchema, error)
	Labels(ctx context.Context) ([]string, error)
	RelationshipTypes(ctx context.Context) ([]string, error)
	ShortestPath(ctx context.Context, startNodeID string, endNodeID string, maxDepth *int, relationshipTypes []string) ([]models.Node, error)
	AllPaths(ctx context.Context, startNodeID string, endNodeID string, maxDepth *int, limit *int) ([][]models.Node, error)
	Neighborhood(ctx context.Context, nodeID string, depth *int, relationshipTypes []string, labels []string, limit *int) (*models.Subgraph, error)
}
type RelationshipResolver interface {
	StartNode(ctx context.Context, obj *models.Relationship) (*models.Node, error)
	EndNode(ctx context.Context, obj *models.Relationship) (*models.Node, error)
}
type SubscriptionResolver interface {
	NodeCreated(ctx context.Context, labels []string) (<-chan *models.Node, error)
	NodeUpdated(ctx context.Context, id *string, labels []string) (<-chan *models.Node, error)
	NodeDeleted(ctx context.Context, labels []string) (<-chan string, error)
	RelationshipCreated(ctx context.Context, types []string) (<-chan *models.Relationship, error)
	RelationshipUpdated(ctx context.Context, id *string, types []string) (<-chan *models.Relationship, error)
	RelationshipDeleted(ctx context.Context, types []string) (<-chan string, error)
	SearchStream(ctx context.Context, query string, options *models.SearchOptions) (<-chan *models.SearchResult, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "BulkCreateResult.created":
		if e.complexity.BulkCreateResult.Created == nil {
			break
		}

		return e.complexity.BulkCreateResult.Created(childComplexity), true
	case "BulkCreateResult.errors":
		if e.complexity.BulkCreateResult.Errors == nil {
			break
		}

		return e.complexity.BulkCreateResult.Errors(childComplexity), true
	case "BulkCreateResult.skipped":
		if e.complexity.BulkCreateResult.Skipped == nil {
			break
		}

		return e.complexity.BulkCreateResult.Skipped(childComplexity), true

	case "BulkDeleteResult.deleted":
		if e.complexity.BulkDeleteResult.Deleted == nil {
			break
		}

		return e.complexity.BulkDeleteResult.Deleted(childComplexity), true
	case "BulkDeleteResult.notFound":
		if e.complexity.BulkDeleteResult.NotFound == nil {
			break
		}

		return e.complexity.BulkDeleteResult.NotFound(childComplexity), true

	case "CypherResult.columns":
		if e.complexity.CypherResult.Columns == nil {
			break
		}

		return e.complexity.CypherResult.Columns(childComplexity), true
	case "CypherResult.executionTimeMs":
		if e.complexity.CypherResult.ExecutionTimeMs == nil {
			break
		}

		return e.complexity.CypherResult.ExecutionTimeMs(childComplexity), true
	case "CypherResult.rowCount":
		if e.complexity.CypherResult.RowCount == nil {
			break
		}

		return e.complexity.CypherResult.RowCount(childComplexity), true
	case "CypherResult.rows":
		if e.complexity.CypherResult.Rows == nil {
			break
		}

		return e.complexity.CypherResult.Rows(childComplexity), true
	case "CypherResult.stats":
		if e.complexity.CypherResult.Stats == nil {
			break
		}

		return e.complexity.CypherResult.Stats(childComplexity), true

	case "CypherStats.containsUpdates":
		if e.complexity.CypherStats.ContainsUpdates == nil {
			break
		}

		return e.complexity.CypherStats.ContainsUpdates(childComplexity), true
	case "CypherStats.labelsAdded":
		if e.complexity.CypherStats.LabelsAdded == nil {
			break
		}

		return e.complexity.CypherStats.LabelsAdded(childComplexity), true
	case "CypherStats.labelsRemoved":
		if e.complexity.CypherStats.LabelsRemoved == nil {
			break
		}

		return e.complexity.CypherStats.LabelsRemoved(childComplexity), true
	case "CypherStats.nodesCreated":
		if e.complexity.CypherStats.NodesCreated == nil {
			break
		}

		return e.complexity.CypherStats.NodesCreated(childComplexity), true
	case "CypherStats.nodesDeleted":
		if e.complexity.CypherStats.NodesDeleted == nil {
			break
		}

		return e.complexity.CypherStats.NodesDeleted(childComplexity), true
	case "CypherStats.propertiesSet":
		if e.complexity.CypherStats.PropertiesSet == nil {
			break
		}

		return e.complexity.CypherStats.PropertiesSet(childComplexity), true
	case "CypherStats.relationshipsCreated":
		if e.complexity.CypherStats.RelationshipsCreated == nil {
			break
		}

		return e.complexity.CypherStats.RelationshipsCreated(childComplexity), true
	case "CypherStats.relationshipsDeleted":
		if e.complexity.CypherStats.RelationshipsDeleted == nil {
			break
		}

		return e.complexity.CypherStats.RelationshipsDeleted(childComplexity), true

	case "DatabaseStats.embeddedNodeCount":
		if e.complexity.DatabaseStats.EmbeddedNodeCount == nil {
			break
		}

		return e.complexity.DatabaseStats.EmbeddedNodeCount(childComplexity), true
	case "DatabaseStats.labels":
		if e.complexity.DatabaseStats.Labels == nil {
			break
		}

		return e.complexity.DatabaseStats.Labels(childComplexity), true
	case "DatabaseStats.memoryUsageBytes":
		if e.complexity.DatabaseStats.MemoryUsageBytes == nil {
			break
		}

		return e.complexity.DatabaseStats.MemoryUsageBytes(childComplexity), true
	case "DatabaseStats.nodeCount":
		if e.complexity.DatabaseStats.NodeCount == nil {
			break
		}

		return e.complexity.DatabaseStats.NodeCount(childComplexity), true
	case "DatabaseStats.relationshipCount":
		if e.complexity.DatabaseStats.RelationshipCount == nil {
			break
		}

		return e.complexity.DatabaseStats.RelationshipCount(childComplexity), true
	case "DatabaseStats.relationshipTypes":
		if e.complexity.DatabaseStats.RelationshipTypes == nil {
			break
		}

		return e.complexity.DatabaseStats.RelationshipTypes(childComplexity), true
	case "DatabaseStats.uptimeSeconds":
		if e.complexity.DatabaseStats.UptimeSeconds == nil {
			break
		}

		return e.complexity.DatabaseStats.UptimeSeconds(childComplexity), true

	case "DecayResult.averageDecayScore":
		if e.complexity.DecayResult.AverageDecayScore == nil {
			break
		}

		return e.complexity.DecayResult.AverageDecayScore(childComplexity), true
	case "DecayResult.nodesDecayed":
		if e.complexity.DecayResult.NodesDecayed == nil {
			break
		}

		return e.complexity.DecayResult.NodesDecayed(childComplexity), true
	case "DecayResult.nodesProcessed":
		if e.complexity.DecayResult.NodesProcessed == nil {
			break
		}

		return e.complexity.DecayResult.NodesProcessed(childComplexity), true

	case "EmbeddingStatus.embedded":
		if e.complexity.EmbeddingStatus.Embedded == nil {
			break
		}

		return e.complexity.EmbeddingStatus.Embedded(childComplexity), true
	case "EmbeddingStatus.pending":
		if e.complexity.EmbeddingStatus.Pending == nil {
			break
		}

		return e.complexity.EmbeddingStatus.Pending(childComplexity), true
	case "EmbeddingStatus.total":
		if e.complexity.EmbeddingStatus.Total == nil {
			break
		}

		return e.complexity.EmbeddingStatus.Total(childComplexity), true
	case "EmbeddingStatus.workerRunning":
		if e.complexity.EmbeddingStatus.WorkerRunning == nil {
			break
		}

		return e.complexity.EmbeddingStatus.WorkerRunning(childComplexity), true

	case "GraphSchema.constraints":
		if e.complexity.GraphSchema.Constraints == nil {
			break
		}

		return e.complexity.GraphSchema.Constraints(childComplexity), true
	case "GraphSchema.nodeLabels":
		if e.complexity.GraphSchema.NodeLabels == nil {
			break
		}

		return e.complexity.GraphSchema.NodeLabels(childComplexity), true
	case "GraphSchema.nodePropertyKeys":
		if e.complexity.GraphSchema.NodePropertyKeys == nil {
			break
		}

		return e.complexity.GraphSchema.NodePropertyKeys(childComplexity), true
	case "GraphSchema.relationshipPropertyKeys":
		if e.complexity.GraphSchema.RelationshipPropertyKeys == nil {
			break
		}

		return e.complexity.GraphSchema.RelationshipPropertyKeys(childComplexity), true
	case "GraphSchema.relationshipTypes":
		if e.complexity.GraphSchema.RelationshipTypes == nil {
			break
		}

		return e.complexity.GraphSchema.RelationshipTypes(childComplexity), true

	case "LabelStats.count":
		if e.complexity.LabelStats.Count == nil {
			break
		}

		return e.complexity.LabelStats.Count(childComplexity), true
	case "LabelStats.label":
		if e.complexity.LabelStats.Label == nil {
			break
		}

		return e.complexity.LabelStats.Label(childComplexity), true

	case "Mutation.bulkCreateNodes":
		if e.complexity.Mutation.BulkCreateNodes == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateNodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateNodes(childComplexity, args["input"].(models.BulkCreateNodesInput)), true
	case "Mutation.bulkCreateRelationships":
		if e.complexity.Mutation.BulkCreateRelationships == nil {
			break
		}

		args, err := ec.field_Mutation_bulkCreateRelationships_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkCreateRelationships(childComplexity, args["input"].(models.BulkCreateRelationshipsInput)), true
	case "Mutation.bulkDeleteNodes":
		if e.complexity.Mutation.BulkDeleteNodes == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteNodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteNodes(childComplexity, args["ids"].([]string)), true
	case "Mutation.bulkDeleteRelationships":
		if e.complexity.Mutation.BulkDeleteRelationships == nil {
			break
		}

		args, err := ec.field_Mutation_bulkDeleteRelationships_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BulkDeleteRelationships(childComplexity, args["ids"].([]string)), true
	case "Mutation.clearAll":
		if e.complexity.Mutation.ClearAll == nil {
			break
		}

		args, err := ec.field_Mutation_clearAll_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ClearAll(childComplexity, args["confirmPhrase"].(string)), true
	case "Mutation.createNode":
		if e.complexity.Mutation.CreateNode == nil {
			break
		}

		args, err := ec.field_Mutation_createNode_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateNode(childComplexity, args["input"].(models.CreateNodeInput)), true
	case "Mutation.createRelationship":
		if e.complexity.Mutation.CreateRelationship == nil {
			break
		}

		args, err := ec.field_Mutation_createRelationship_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRelationship(childComplexity, args["input"].(models.CreateRelationshipInput)), true
	case "Mutation.deleteNode":
		if e.complexity.Mutation.DeleteNode == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNode_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNode(childComplexity, args["id"].(string)), true
	case "Mutation.deleteRelationship":
		if e.complexity.Mutation.DeleteRelationship == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRelationship_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRelationship(childComplexity, args["id"].(string)), true
	case "Mutation.executeCypher":
		if e.complexity.Mutation.ExecuteCypher == nil {
			break
		}

		args, err := ec.field_Mutation_executeCypher_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExecuteCypher(childComplexity, args["input"].(models.CypherInput)), true
	case "Mutation.mergeNode":
		if e.complexity.Mutation.MergeNode == nil {
			break
		}

		args, err := ec.field_Mutation_mergeNode_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MergeNode(childComplexity, args["labels"].([]string), args["matchProperties"].(models.JSON), args["setProperties"].(models.JSON)), true
	case "Mutation.mergeRelationship":
		if e.complexity.Mutation.MergeRelationship == nil {
			break
		}

		args, err := ec.field_Mutation_mergeRelationship_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MergeRelationship(childComplexity, args["startNodeId"].(string), args["endNodeId"].(string), args["type"].(string), args["properties"].(models.JSON)), true
	case "Mutation.rebuildSearchIndex":
		if e.complexity.Mutation.RebuildSearchIndex == nil {
			break
		}

		return e.complexity.Mutation.RebuildSearchIndex(childComplexity), true
	case "Mutation.runDecay":
		if e.complexity.Mutation.RunDecay == nil {
			break
		}

		return e.complexity.Mutation.RunDecay(childComplexity), true
	case "Mutation.triggerEmbedding":
		if e.complexity.Mutation.TriggerEmbedding == nil {
			break
		}

		args, err := ec.field_Mutation_triggerEmbedding_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TriggerEmbedding(childComplexity, args["regenerate"].(*bool)), true
	case "Mutation.updateNode":
		if e.complexity.Mutation.UpdateNode == nil {
			break
		}

		args, err := ec.field_Mutation_updateNode_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNode(childComplexity, args["input"].(models.UpdateNodeInput)), true
	case "Mutation.updateRelationship":
		if e.complexity.Mutation.UpdateRelationship == nil {
			break
		}

		args, err := ec.field_Mutation_updateRelationship_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRelationship(childComplexity, args["input"].(models.UpdateRelationshipInput)), true

	case "Node.accessCount":
		if e.complexity.Node.AccessCount == nil {
			break
		}

		return e.complexity.Node.AccessCount(childComplexity), true
	case "Node.createdAt":
		if e.complexity.Node.CreatedAt == nil {
			break
		}

		return e.complexity.Node.CreatedAt(childComplexity), true
	case "Node.decayScore":
		if e.complexity.Node.DecayScore == nil {
			break
		}

		return e.complexity.Node.DecayScore(childComplexity), true
	case "Node.embeddingDimensions":
		if e.complexity.Node.EmbeddingDimensions == nil {
			break
		}

		return e.complexity.Node.EmbeddingDimensions(childComplexity), true
	case "Node.hasEmbedding":
		if e.complexity.Node.HasEmbedding == nil {
			break
		}

		return e.complexity.Node.HasEmbedding(childComplexity), true
	case "Node.id":
		if e.complexity.Node.ID == nil {
			break
		}

		return e.complexity.Node.ID(childComplexity), true
	case "Node.incoming":
		if e.complexity.Node.Incoming == nil {
			break
		}

		args, err := ec.field_Node_incoming_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Incoming(childComplexity, args["types"].([]string), args["limit"].(*int)), true
	case "Node.internalId":
		if e.complexity.Node.InternalID == nil {
			break
		}

		return e.complexity.Node.InternalID(childComplexity), true
	case "Node.labels":
		if e.complexity.Node.Labels == nil {
			break
		}

		return e.complexity.Node.Labels(childComplexity), true
	case "Node.lastAccessed":
		if e.complexity.Node.LastAccessed == nil {
			break
		}

		return e.complexity.Node.LastAccessed(childComplexity), true
	case "Node.neighbors":
		if e.complexity.Node.Neighbors == nil {
			break
		}

		args, err := ec.field_Node_neighbors_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Neighbors(childComplexity, args["direction"].(*models.RelationshipDirection), args["relationshipTypes"].([]string), args["labels"].([]string), args["limit"].(*int)), true
	case "Node.outgoing":
		if e.complexity.Node.Outgoing == nil {
			break
		}

		args, err := ec.field_Node_outgoing_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Outgoing(childComplexity, args["types"].([]string), args["limit"].(*int)), true
	case "Node.properties":
		if e.complexity.Node.Properties == nil {
			break
		}

		return e.complexity.Node.Properties(childComplexity), true
	case "Node.relationships":
		if e.complexity.Node.Relationships == nil {
			break
		}

		args, err := ec.field_Node_relationships_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Relationships(childComplexity, args["types"].([]string), args["direction"].(*models.RelationshipDirection), args["limit"].(*int)), true
	case "Node.similar":
		if e.complexity.Node.Similar == nil {
			break
		}

		args, err := ec.field_Node_similar_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Similar(childComplexity, args["limit"].(*int), args["threshold"].(*float64)), true
	case "Node.updatedAt":
		if e.complexity.Node.UpdatedAt == nil {
			break
		}

		return e.complexity.Node.UpdatedAt(childComplexity), true

	case "Query.allNodes":
		if e.complexity.Query.AllNodes == nil {
			break
		}

		args, err := ec.field_Query_allNodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllNodes(childComplexity, args["labels"].([]string), args["limit"].(*int), args["offset"].(*int)), true
	case "Query.allPaths":
		if e.complexity.Query.AllPaths == nil {
			break
		}

		args, err := ec.field_Query_allPaths_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllPaths(childComplexity, args["startNodeId"].(string), args["endNodeId"].(string), args["maxDepth"].(*int), args["limit"].(*int)), true
	case "Query.allRelationships":
		if e.complexity.Query.AllRelationships == nil {
			break
		}

		args, err := ec.field_Query_allRelationships_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllRelationships(childComplexity, args["types"].([]string), args["limit"].(*int), args["offset"].(*int)), true
	case "Query.cypher":
		if e.complexity.Query.Cypher == nil {
			break
		}

		args, err := ec.field_Query_cypher_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cypher(childComplexity, args["input"].(models.CypherInput)), true
	case "Query.labels":
		if e.complexity.Query.Labels == nil {
			break
		}

		return e.complexity.Query.Labels(childComplexity), true
	case "Query.neighborhood":
		if e.complexity.Query.Neighborhood == nil {
			break
		}

		args, err := ec.field_Query_neighborhood_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Neighborhood(childComplexity, args["nodeId"].(string), args["depth"].(*int), args["relationshipTypes"].([]string), args["labels"].([]string), args["limit"].(*int)), true
	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true
	case "Query.nodeCount":
		if e.complexity.Query.NodeCount == nil {
			break
		}

		args, err := ec.field_Query_nodeCount_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.NodeCount(childComplexity, args["label"].(*string)), true
	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true
	case "Query.nodesByLabel":
		if e.complexity.Query.NodesByLabel == nil {
			break
		}

		args, err := ec.field_Query_nodesByLabel_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.NodesByLabel(childComplexity, args["label"].(string), args["limit"].(*int), args["offset"].(*int)), true
	case "Query.relationship":
		if e.complexity.Query.Relationship == nil {
			break
		}

		args, err := ec.field_Query_relationship_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Relationship(childComplexity, args["id"].(string)), true
	case "Query.relationshipCount":
		if e.complexity.Query.RelationshipCount == nil {
			break
		}

		args, err := ec.field_Query_relationshipCount_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RelationshipCount(childComplexity, args["type"].(*string)), true
	case "Query.relationshipTypes":
		if e.complexity.Query.RelationshipTypes == nil {
			break
		}

		return e.complexity.Query.RelationshipTypes(childComplexity), true
	case "Query.relationshipsBetween":
		if e.complexity.Query.RelationshipsBetween == nil {
			break
		}

		args, err := ec.field_Query_relationshipsBetween_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RelationshipsBetween(childComplexity, args["startNodeId"].(string), args["endNodeId"].(string)), true
	case "Query.relationshipsByType":
		if e.complexity.Query.RelationshipsByType == nil {
			break
		}

		args, err := ec.field_Query_relationshipsByType_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RelationshipsByType(childComplexity, args["type"].(string), args["limit"].(*int), args["offset"].(*int)), true
	case "Query.schema":
		if e.complexity.Query.Schema == nil {
			break
		}

		return e.complexity.Query.Schema(childComplexity), true
	case "Query.search":
		if e.complexity.Query.Search == nil {
			break
		}

		args, err := ec.field_Query_search_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Search(childComplexity, args["query"].(string), args["options"].(*models.SearchOptions)), true
	case "Query.searchByProperty":
		if e.complexity.Query.SearchByProperty == nil {
			break
		}

		args, err := ec.field_Query_searchByProperty_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchByProperty(childComplexity, args["key"].(string), args["value"].(models.JSON), args["labels"].([]string), args["limit"].(*int)), true
	case "Query.shortestPath":
		if e.complexity.Query.ShortestPath == nil {
			break
		}

		args, err := ec.field_Query_shortestPath_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ShortestPath(childComplexity, args["startNodeId"].(string), args["endNodeId"].(string), args["maxDepth"].(*int), args["relationshipTypes"].([]string)), true
	case "Query.similar":
		if e.complexity.Query.Similar == nil {
			break
		}

		args, err := ec.field_Query_similar_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Similar(childComplexity, args["nodeId"].(string), args["limit"].(*int), args["threshold"].(*float64)), true
	case "Query.stats":
		if e.complexity.Query.Stats == nil {
			break
		}

		return e.complexity.Query.Stats(childComplexity), true

	case "Relationship.autoGenerated":
		if e.complexity.Relationship.AutoGenerated == nil {
			break
		}

		return e.complexity.Relationship.AutoGenerated(childComplexity), true
	case "Relationship.confidence":
		if e.complexity.Relationship.Confidence == nil {
			break
		}

		return e.complexity.Relationship.Confidence(childComplexity), true
	case "Relationship.createdAt":
		if e.complexity.Relationship.CreatedAt == nil {
			break
		}

		return e.complexity.Relationship.CreatedAt(childComplexity), true
	case "Relationship.endNode":
		if e.complexity.Relationship.EndNode == nil {
			break
		}

		return e.complexity.Relationship.EndNode(childComplexity), true
	case "Relationship.id":
		if e.complexity.Relationship.ID == nil {
			break
		}

		return e.complexity.Relationship.ID(childComplexity), true
	case "Relationship.internalId":
		if e.complexity.Relationship.InternalID == nil {
			break
		}

		return e.complexity.Relationship.InternalID(childComplexity), true
	case "Relationship.properties":
		if e.complexity.Relationship.Properties == nil {
			break
		}

		return e.complexity.Relationship.Properties(childComplexity), true
	case "Relationship.startNode":
		if e.complexity.Relationship.StartNode == nil {
			break
		}

		return e.complexity.Relationship.StartNode(childComplexity), true
	case "Relationship.type":
		if e.complexity.Relationship.Type == nil {
			break
		}

		return e.complexity.Relationship.Type(childComplexity), true
	case "Relationship.updatedAt":
		if e.complexity.Relationship.UpdatedAt == nil {
			break
		}

		return e.complexity.Relationship.UpdatedAt(childComplexity), true

	case "RelationshipTypeStats.count":
		if e.complexity.RelationshipTypeStats.Count == nil {
			break
		}

		return e.complexity.RelationshipTypeStats.Count(childComplexity), true
	case "RelationshipTypeStats.type":
		if e.complexity.RelationshipTypeStats.Type == nil {
			break
		}

		return e.complexity.RelationshipTypeStats.Type(childComplexity), true

	case "SchemaConstraint.entityType":
		if e.complexity.SchemaConstraint.EntityType == nil {
			break
		}

		return e.complexity.SchemaConstraint.EntityType(childComplexity), true
	case "SchemaConstraint.labelsOrTypes":
		if e.complexity.SchemaConstraint.LabelsOrTypes == nil {
			break
		}

		return e.complexity.SchemaConstraint.LabelsOrTypes(childComplexity), true
	case "SchemaConstraint.name":
		if e.complexity.SchemaConstraint.Name == nil {
			break
		}

		return e.complexity.SchemaConstraint.Name(childComplexity), true
	case "SchemaConstraint.properties":
		if e.complexity.SchemaConstraint.Properties == nil {
			break
		}

		return e.complexity.SchemaConstraint.Properties(childComplexity), true
	case "SchemaConstraint.type":
		if e.complexity.SchemaConstraint.Type == nil {
			break
		}

		return e.complexity.SchemaConstraint.Type(childComplexity), true

	case "SearchResponse.bm25SearchUsed":
		if e.complexity.SearchResponse.BM25SearchUsed == nil {
			break
		}

		return e.complexity.SearchResponse.BM25SearchUsed(childComplexity), true
	case "SearchResponse.executionTimeMs":
		if e.complexity.SearchResponse.ExecutionTimeMs == nil {
			break
		}

		return e.complexity.SearchResponse.ExecutionTimeMs(childComplexity), true
	case "SearchResponse.method":
		if e.complexity.SearchResponse.Method == nil {
			break
		}

		return e.complexity.SearchResponse.Method(childComplexity), true
	case "SearchResponse.results":
		if e.complexity.SearchResponse.Results == nil {
			break
		}

		return e.complexity.SearchResponse.Results(childComplexity), true
	case "SearchResponse.totalCount":
		if e.complexity.SearchResponse.TotalCount == nil {
			break
		}

		return e.complexity.SearchResponse.TotalCount(childComplexity), true
	case "SearchResponse.vectorSearchUsed":
		if e.complexity.SearchResponse.VectorSearchUsed == nil {
			break
		}

		return e.complexity.SearchResponse.VectorSearchUsed(childComplexity), true

	case "SearchResult.bm25Rank":
		if e.complexity.SearchResult.BM25Rank == nil {
			break
		}

		return e.complexity.SearchResult.BM25Rank(childComplexity), true
	case "SearchResult.bm25Score":
		if e.complexity.SearchResult.BM25Score == nil {
			break
		}

		return e.complexity.SearchResult.BM25Score(childComplexity), true
	case "SearchResult.foundBy":
		if e.complexity.SearchResult.FoundBy == nil {
			break
		}

		return e.complexity.SearchResult.FoundBy(childComplexity), true
	case "SearchResult.node":
		if e.complexity.SearchResult.Node == nil {
			break
		}

		return e.complexity.SearchResult.Node(childComplexity), true
	case "SearchResult.rrfScore":
		if e.complexity.SearchResult.RRFScore == nil {
			break
		}

		return e.complexity.SearchResult.RRFScore(childComplexity), true
	case "SearchResult.score":
		if e.complexity.SearchResult.Score == nil {
			break
		}

		return e.complexity.SearchResult.Score(childComplexity), true
	case "SearchResult.vectorRank":
		if e.complexity.SearchResult.VectorRank == nil {
			break
		}

		return e.complexity.SearchResult.VectorRank(childComplexity), true
	case "SearchResult.vectorScore":
		if e.complexity.SearchResult.VectorScore == nil {
			break
		}

		return e.complexity.SearchResult.VectorScore(childComplexity), true

	case "SimilarNode.node":
		if e.complexity.SimilarNode.Node == nil {
			break
		}

		return e.complexity.SimilarNode.Node(childComplexity), true
	case "SimilarNode.similarity":
		if e.complexity.SimilarNode.Similarity == nil {
			break
		}

		return e.complexity.SimilarNode.Similarity(childComplexity), true

	case "Subgraph.nodes":
		if e.complexity.Subgraph.Nodes == nil {
			break
		}

		return e.complexity.Subgraph.Nodes(childComplexity), true
	case "Subgraph.relationships":
		if e.complexity.Subgraph.Relationships == nil {
			break
		}

		return e.complexity.Subgraph.Relationships(childComplexity), true

	case "Subscription.nodeCreated":
		if e.complexity.Subscription.NodeCreated == nil {
			break
		}

		args, err := ec.field_Subscription_nodeCreated_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.NodeCreated(childComplexity, args["labels"].([]string)), true
	case "Subscription.nodeDeleted":
		if e.complexity.Subscription.NodeDeleted == nil {
			break
		}

		args, err := ec.field_Subscription_nodeDeleted_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.NodeDeleted(childComplexity, args["labels"].([]string)), true
	case "Subscription.nodeUpdated":
		if e.complexity.Subscription.NodeUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_nodeUpdated_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.NodeUpdated(childComplexity, args["id"].(*string), args["labels"].([]string)), true
	case "Subscription.relationshipCreated":
		if e.complexity.Subscription.RelationshipCreated == nil {
			break
		}

		args, err := ec.field_Subscription_relationshipCreated_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.RelationshipCreated(childComplexity, args["types"].([]string)), true
	case "Subscription.relationshipDeleted":
		if e.complexity.Subscription.RelationshipDeleted == nil {
			break
		}

		args, err := ec.field_Subscription_relationshipDeleted_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.RelationshipDeleted(childComplexity, args["types"].([]string)), true
	case "Subscription.relationshipUpdated":
		if e.complexity.Subscription.RelationshipUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_relationshipUpdated_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.RelationshipUpdated(childComplexity, args["id"].(*string), args["types"].([]string)), true
	case "Subscription.searchStream":
		if e.complexity.Subscription.SearchStream == nil {
			break
		}

		args, err := ec.field_Subscription_searchStream_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.SearchStream(childComplexity, args["query"].(string), args["options"].(*models.SearchOptions)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBulkCreateNodesInput,
		ec.unmarshalInputBulkCreateRelationshipsInput,
		ec.unmarshalInputCreateNodeInput,
		ec.unmarshalInputCreateRelationshipInput,
		ec.unmarshalInputCypherInput,
		ec.unmarshalInputSearchOptions,
		ec.unmarshalInputUpdateNodeInput,
		ec.unmarshalInputUpdateRelationshipInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/schema.graphql", Input: `# NornicDB GraphQL Schema
# ======================
# This schema provides a complete GraphQL API for NornicDB, supporting:
# - Full CRUD operations on nodes and relationships
# - Advanced search with vector similarity and BM25
# - Cypher query pass-through for complex graph operations
# - Subscriptions for real-time updates
# - Schema introspection and graph analytics

# =============================================================================
# SCALARS
# =============================================================================

"""
Custom scalar for arbitrary JSON objects (node/edge properties)
"""
scalar JSON

"""
Custom scalar for timestamps (RFC3339 format)
"""
scalar DateTime

"""
Custom scalar for 32-bit float arrays (embeddings)
"""
scalar FloatArray

# =============================================================================
# ENUMS
# =============================================================================

"""
Memory tier classification based on cognitive science decay patterns
"""
enum MemoryTier {
  """
  Short-term memories with 7-day half-life
  """
  EPISODIC
  """
  Facts and concepts with 69-day half-life
  """
  SEMANTIC
  """
  Skills and patterns with 693-day half-life
  """
  PROCEDURAL
}

"""
Direction for relationship traversal
"""
enum RelationshipDirection {
  """
  Outgoing relationships from the node
  """
  OUTGOING
  """
  Incoming relationships to the node
  """
  INCOMING
  """
  Both directions
  """
  BOTH
}

"""
Sorting options for search results
"""
enum SearchSortBy {
  """
  Sort by relevance score (default)
  """
  RELEVANCE
  """
  Sort by creation time
  """
  CREATED_AT
  """
  Sort by last access time
  """
  LAST_ACCESSED
  """
  Sort by decay score
  """
  DECAY_SCORE
  """
  Sort by access count
  """
  ACCESS_COUNT
}

"""
Search method to use
"""
enum SearchMethod {
  """
  Hybrid RRF search combining vector and BM25
  """
  HYBRID
  """
  Vector similarity search only
  """
  VECTOR
  """
  BM25 full-text search only
  """
  BM25
}

"""
Sort order for results
"""
enum SortOrder {
  ASC
  DESC
}

# =============================================================================
# CORE TYPES
# =============================================================================

"""
A node in the NornicDB graph.

Nodes are the fundamental entities representing people, documents, concepts,
or any other domain objects. They follow the labeled property graph model
with Neo4j-compatible labels and properties.
"""
type Node {
  """
  Unique identifier (elementId format: 4:nornicdb:uuid)
  """
  id: ID!

  """
  Raw internal ID (without elementId prefix)
  """
  internalId: String!

  """
  Type labels (e.g., Person, Document, Concept)
  """
  labels: [String!]!

  """
  Key-value properties
  """
  properties: JSON!

  """
  When the node was created
  """
  createdAt: DateTime

  """
  When the node was last updated
  """
  updatedAt: DateTime

  """
  Memory decay score (1.0 = fresh, 0.0 = decayed)
  """
  decayScore: Float

  """
  When the node was last accessed
  """
  lastAccessed: DateTime

  """
  Total number of times accessed
  """
  accessCount: Int

  """
  Whether this node has an embedding vector
  """
  hasEmbedding: Boolean!

  """
  Embedding vector dimensions (0 if no embedding)
  """
  embeddingDimensions: Int!

  # Traversal fields
  """
  Relationships connected to this node
  """
  relationships(
    """
    Filter by relationship type(s)
    """
    types: [String!]
    """
    Direction of relationships
    """
    direction: RelationshipDirection = BOTH
    """
    Maximum number to return
    """
    limit: Int = 100
  ): [Relationship!]!

  """
  Outgoing relationships from this node
  """
  outgoing(types: [String!], limit: Int = 100): [Relationship!]!

  """
  Incoming relationships to this node
  """
  incoming(types: [String!], limit: Int = 100): [Relationship!]!

  """
  Connected nodes (neighbors)
  """
  neighbors(
    direction: RelationshipDirection = BOTH
    relationshipTypes: [String!]
    labels: [String!]
    limit: Int = 100
  ): [Node!]!

  """
  Find similar nodes based on embedding similarity
  """
  similar(limit: Int = 10, threshold: Float = 0.7): [SimilarNode!]!
}

"""
A relationship (edge) between two nodes.

Relationships are directed connections with a type and optional properties.
They can be manually created or auto-generated by NornicDB's inference engine.
"""
type Relationship {
  """
  Unique identifier (elementId format: 5:nornicdb:uuid)
  """
  id: ID!

  """
  Raw internal ID
  """
  internalId: String!

  """
  Relationship type (e.g., KNOWS, CITES, SIMILAR_TO)
  """
  type: String!

  """
  Source node
  """
  startNode: Node!

  """
  Target node
  """
  endNode: Node!

  """
  Key-value properties
  """
  properties: JSON!

  """
  When the relationship was created
  """
  createdAt: DateTime

  """
  When the relationship was last updated
  """
  updatedAt: DateTime

  """
  Confidence score (0.0-1.0) for auto-generated relationships
  """
  confidence: Float

  """
  Whether this was auto-generated by inference engine
  """
  autoGenerated: Boolean!
}

"""
A similar node result with similarity score
"""
type SimilarNode {
  """
  The similar node
  """
  node: Node!

  """
  Similarity score (0.0-1.0, higher = more similar)
  """
  similarity: Float!
}

# =============================================================================
# SEARCH TYPES
# =============================================================================

"""
Search result with scoring details
"""
type SearchResult {
  """
  The matched node
  """
  node: Node!

  """
  Combined RRF score
  """
  score: Float!

  """
  RRF fusion score (when using hybrid search)
  """
  rrfScore: Float

  """
  Vector similarity score (when using vector search)
  """
  vectorScore: Float

  """
  BM25 text relevance score (when using BM25 search)
  """
  bm25Score: Float

  """
  Rank in vector search results
  """
  vectorRank: Int

  """
  Rank in BM25 search results
  """
  bm25Rank: Int

  """
  Which search method found this result
  """
  foundBy: [String!]!
}

"""
Search response with results and metadata
"""
type SearchResponse {
  """
  Search results
  """
  results: [SearchResult!]!

  """
  Total number of matching results (may be > returned results)
  """
  totalCount: Int!

  """
  Search method used
  """
  method: String!

  """
  Query execution time in milliseconds
  """
  executionTimeMs: Float!

  """
  Whether vector search was available
  """
  vectorSearchUsed: Boolean!

  """
  Whether BM25 search was available
  """
  bm25SearchUsed: Boolean!
}

"""
Options for search queries
"""
input SearchOptions {
  """
  Maximum results to return
  """
  limit: Int = 10

  """
  Offset for pagination
  """
  offset: Int = 0

  """
  Filter by labels
  """
  labels: [String!]

  """
  Search method to use
  """
  method: SearchMethod = HYBRID

  """
  Minimum score threshold (0.0-1.0)
  """
  minScore: Float = 0.0

  """
  Sort results by
  """
  sortBy: SearchSortBy = RELEVANCE

  """
  Sort order
  """
  sortOrder: SortOrder = DESC

  """
  Include nodes below decay threshold
  """
  includeDecayed: Boolean = false

  """
  Minimum decay score to include
  """
  minDecayScore: Float = 0.0

  """
  Property filters (JSON object with key-value pairs)
  """
  propertyFilters: JSON
}

# =============================================================================
# CYPHER TYPES
# =============================================================================

"""
Cypher query result
"""
type CypherResult {
  """
  Column names
  """
  columns: [String!]!

  """
  Result rows (array of arrays)
  """
  rows: [[JSON!]!]!

  """
  Number of rows returned
  """
  rowCount: Int!

  """
  Query statistics
  """
  stats: CypherStats

  """
  Execution time in milliseconds
  """
  executionTimeMs: Float!
}

"""
Cypher query execution statistics
"""
type CypherStats {
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
  propertiesSet: Int!
  labelsAdded: Int!
  labelsRemoved: Int!
  containsUpdates: Boolean!
}

# =============================================================================
# GRAPH ANALYTICS TYPES
# =============================================================================

"""
Database statistics and metrics
"""
type DatabaseStats {
  """
  Total number of nodes
  """
  nodeCount: Int!

  """
  Total number of relationships
  """
  relationshipCount: Int!

  """
  Unique labels in use
  """
  labels: [LabelStats!]!

  """
  Unique relationship types in use
  """
  relationshipTypes: [RelationshipTypeStats!]!

  """
  Number of nodes with embeddings
  """
  embeddedNodeCount: Int!

  """
  Database uptime in seconds
  """
  uptimeSeconds: Float!

  """
  Memory usage in bytes
  """
  memoryUsageBytes: Int!
}

"""
Statistics for a specific label
"""
type LabelStats {
  """
  Label name
  """
  label: String!

  """
  Number of nodes with this label
  """
  count: Int!
}

"""
Statistics for a specific relationship type
"""
type RelationshipTypeStats {
  """
  Relationship type
  """
  type: String!

  """
  Number of relationships of this type
  """
  count: Int!
}

"""
Graph schema information
"""
type GraphSchema {
  """
  All node labels
  """
  nodeLabels: [String!]!

  """
  All relationship types
  """
  relationshipTypes: [String!]!

  """
  Property keys used across all nodes
  """
  nodePropertyKeys: [String!]!

  """
  Property keys used across all relationships
  """
  relationshipPropertyKeys: [String!]!

  """
  Constraints and indexes
  """
  constraints: [SchemaConstraint!]!
}

"""
Schema constraint information
"""
type SchemaConstraint {
  """
  Constraint name
  """
  name: String!

  """
  Constraint type (UNIQUE, EXISTS, etc.)
  """
  type: String!

  """
  Entity type (NODE or RELATIONSHIP)
  """
  entityType: String!

  """
  Labels or types this applies to
  """
  labelsOrTypes: [String!]!

  """
  Properties this applies to
  """
  properties: [String!]!
}

# =============================================================================
# INPUT TYPES
# =============================================================================

"""
Input for creating a new node
"""
input CreateNodeInput {
  """
  Optional custom ID (auto-generated if not provided)
  """
  id: String

  """
  Type labels
  """
  labels: [String!]!

  """
  Key-value properties
  """
  properties: JSON!

  """
  Memory tier for decay calculation
  """
  tier: MemoryTier = SEMANTIC

  """
  Pre-computed embedding vector (optional)
  """
  embedding: FloatArray
}

"""
Input for updating a node
"""
input UpdateNodeInput {
  """
  Node ID to update
  """
  id: ID!

  """
  Labels to set (replaces existing)
  """
  labels: [String!]

  """
  Properties to set/update
  """
  properties: JSON

  """
  Properties to remove by key
  """
  removeProperties: [String!]

  """
  Labels to add
  """
  addLabels: [String!]

  """
  Labels to remove
  """
  removeLabels: [String!]

  """
  Update embedding
  """
  embedding: FloatArray
}

"""
Input for creating a relationship
"""
input CreateRelationshipInput {
  """
  Optional custom ID
  """
  id: String

  """
  Source node ID
  """
  startNodeId: ID!

  """
  Target node ID
  """
  endNodeId: ID!

  """
  Relationship type
  """
  type: String!

  """
  Key-value properties
  """
  properties: JSON
}

"""
Input for updating a relationship
"""
input UpdateRelationshipInput {
  """
  Relationship ID to update
  """
  id: ID!

  """
  New relationship type
  """
  type: String

  """
  Properties to set/update
  """
  properties: JSON

  """
  Properties to remove by key
  """
  removeProperties: [String!]
}

"""
Input for bulk node creation
"""
input BulkCreateNodesInput {
  """
  Nodes to create
  """
  nodes: [CreateNodeInput!]!

  """
  Skip duplicates instead of failing
  """
  skipDuplicates: Boolean = false
}

"""
Input for bulk relationship creation
"""
input BulkCreateRelationshipsInput {
  """
  Relationships to create
  """
  relationships: [CreateRelationshipInput!]!

  """
  Skip invalid references instead of failing
  """
  skipInvalid: Boolean = false
}

"""
Input for Cypher query execution
"""
input CypherInput {
  """
  Cypher statement
  """
  statement: String!

  """
  Query parameters
  """
  parameters: JSON

  """
  Timeout in milliseconds
  """
  timeoutMs: Int
}

# =============================================================================
# QUERIES
# =============================================================================

type Query {
  # ------ Node Queries ------

  """
  Get a node by ID
  """
  node(id: ID!): Node

  """
  Get multiple nodes by IDs
  """
  nodes(ids: [ID!]): [Node!]!

  """
  Get all nodes with optional filtering
  """
  allNodes(labels: [String!], limit: Int = 100, offset: Int = 0): [Node!]!

  """
  Get nodes by label
  """
  nodesByLabel(label: String!, limit: Int = 100, offset: Int = 0): [Node!]!

  """
  Count nodes (optionally by label)
  """
  nodeCount(label: String): Int!

  # ------ Relationship Queries ------

  """
  Get a relationship by ID
  """
  relationship(id: ID!): Relationship

  """
  Get all relationships with optional filtering
  """
  allRelationships(
    types: [String!]
    limit: Int = 100
    offset: Int = 0
  ): [Relationship!]!

  """
  Get relationships by type
  """
  relationshipsByType(
    type: String!
    limit: Int = 100
    offset: Int = 0
  ): [Relationship!]!

  """
  Get relationships between two nodes
  """
  relationshipsBetween(startNodeId: ID!, endNodeId: ID!): [Relationship!]!

  """
  Count relationships (optionally by type)
  """
  relationshipCount(type: String): Int!

  # ------ Search Queries ------

  """
  Perform hybrid search (vector + BM25)
  """
  search(query: String!, options: SearchOptions): SearchResponse!

  """
  Find nodes similar to a given node
  """
  similar(nodeId: ID!, limit: Int = 10, threshold: Float = 0.7): [SimilarNode!]!

  """
  Search nodes by property value
  """
  searchByProperty(
    key: String!
    value: JSON!
    labels: [String!]
    limit: Int = 100
  ): [Node!]!

  # ------ Cypher Queries ------

  """
  Execute a Cypher query
  """
  cypher(input: CypherInput!): CypherResult!

  # ------ Schema & Analytics ------

  """
  Get database statistics
  """
  stats: DatabaseStats!

  """
  Get graph schema information
  """
  schema: GraphSchema!

  """
  Get all unique labels
  """
  labels: [String!]!

  """
  Get all unique relationship types
  """
  relationshipTypes: [String!]!

  # ------ Graph Traversal Queries ------

  """
  Find shortest path between two nodes
  """
  shortestPath(
    startNodeId: ID!
    endNodeId: ID!
    maxDepth: Int = 10
    relationshipTypes: [String!]
  ): [Node!]

  """
  Find all paths between two nodes
  """
  allPaths(
    startNodeId: ID!
    endNodeId: ID!
    maxDepth: Int = 5
    limit: Int = 10
  ): [[Node!]!]!

  """
  Get node neighborhood (subgraph)
  """
  neighborhood(
    nodeId: ID!
    depth: Int = 1
    relationshipTypes: [String!]
    labels: [String!]
    limit: Int = 100
  ): Subgraph!
}

"""
A subgraph containing nodes and relationships
"""
type Subgraph {
  """
  Nodes in the subgraph
  """
  nodes: [Node!]!

  """
  Relationships in the subgraph
  """
  relationships: [Relationship!]!
}

# =============================================================================
# MUTATIONS
# =============================================================================

type Mutation {
  # ------ Node Mutations ------

  """
  Create a new node
  """
  createNode(input: CreateNodeInput!): Node!

  """
  Update an existing node
  """
  updateNode(input: UpdateNodeInput!): Node!

  """
  Delete a node
  """
  deleteNode(id: ID!): Boolean!

  """
  Bulk create nodes
  """
  bulkCreateNodes(input: BulkCreateNodesInput!): BulkCreateResult!

  """
  Bulk delete nodes
  """
  bulkDeleteNodes(ids: [ID!]!): BulkDeleteResult!

  """
  Merge a node (create or update)
  """
  mergeNode(
    labels: [String!]!
    matchProperties: JSON!
    setProperties: JSON
  ): Node!

  # ------ Relationship Mutations ------

  """
  Create a new relationship
  """
  createRelationship(input: CreateRelationshipInput!): Relationship!

  """
  Update an existing relationship
  """
  updateRelationship(input: UpdateRelationshipInput!): Relationship!

  """
  Delete a relationship
  """
  deleteRelationship(id: ID!): Boolean!

  """
  Bulk create relationships
  """
  bulkCreateRelationships(
    input: BulkCreateRelationshipsInput!
  ): BulkCreateResult!

  """
  Bulk delete relationships
  """
  bulkDeleteRelationships(ids: [ID!]!): BulkDeleteResult!

  """
  Merge a relationship (create or update)
  """
  mergeRelationship(
    startNodeId: ID!
    endNodeId: ID!
    type: String!
    properties: JSON
  ): Relationship!

  # ------ Cypher Mutations ------

  """
  Execute a Cypher mutation
  """
  executeCypher(input: CypherInput!): CypherResult!

  # ------ Maintenance Mutations ------

  """
  Trigger embedding generation for nodes without embeddings
  """
  triggerEmbedding(regenerate: Boolean = false): EmbeddingStatus!

  """
  Rebuild search indexes
  """
  rebuildSearchIndex: Boolean!

  """
  Run memory decay simulation
  """
  runDecay: DecayResult!

  """
  Clear all data (dangerous!)
  """
  clearAll(confirmPhrase: String!): Boolean!
}

"""
Result of bulk create operation
"""
type BulkCreateResult {
  """
  Number of items successfully created
  """
  created: Int!

  """
  Number of items skipped
  """
  skipped: Int!

  """
  Errors encountered (if any)
  """
  errors: [String!]!
}

"""
Result of bulk delete operation
"""
type BulkDeleteResult {
  """
  Number of items successfully deleted
  """
  deleted: Int!

  """
  IDs that were not found
  """
  notFound: [ID!]!
}

"""
Embedding generation status
"""
type EmbeddingStatus {
  """
  Number of nodes pending embedding
  """
  pending: Int!

  """
  Number of nodes with embeddings
  """
  embedded: Int!

  """
  Total node count
  """
  total: Int!

  """
  Whether embedding worker is running
  """
  workerRunning: Boolean!
}

"""
Memory decay simulation result
"""
type DecayResult {
  """
  Number of nodes processed
  """
  nodesProcessed: Int!

  """
  Number of nodes that decayed below threshold
  """
  nodesDecayed: Int!

  """
  Average decay score after simulation
  """
  averageDecayScore: Float!
}

# =============================================================================
# SUBSCRIPTIONS
# =============================================================================

type Subscription {
  """
  Subscribe to node creation events
  """
  nodeCreated(labels: [String!]): Node!

  """
  Subscribe to node update events
  """
  nodeUpdated(id: ID, labels: [String!]): Node!

  """
  Subscribe to node deletion events
  """
  nodeDeleted(labels: [String!]): ID!

  """
  Subscribe to relationship creation events
  """
  relationshipCreated(types: [String!]): Relationship!

  """
  Subscribe to relationship update events
  """
  relationshipUpdated(id: ID, types: [String!]): Relationship!

  """
  Subscribe to relationship deletion events
  """
  relationshipDeleted(types: [String!]): ID!

  """
  Subscribe to search results (streaming results)
  """
  searchStream(query: String!, options: SearchOptions): SearchResult!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_bulkCreateNodes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkCreateNodesInput2githubcomornerydnornicdbpkggraphqlmodelsBulkCreateNodesInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkCreateRelationships_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNBulkCreateRelationshipsInput2githubcomornerydnornicdbpkggraphqlmodelsBulkCreateRelationshipsInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteNodes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bulkDeleteRelationships_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_clearAll_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "confirmPhrase", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["confirmPhrase"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createNode_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateNodeInput2githubcomornerydnornicdbpkggraphqlmodelsCreateNodeInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createRelationship_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateRelationshipInput2githubcomornerydnornicdbpkggraphqlmodelsCreateRelationshipInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteNode_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteRelationship_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_executeCypher_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCypherInput2githubcomornerydnornicdbpkggraphqlmodelsCypherInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_mergeNode_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "labels", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["labels"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "matchProperties", ec.unmarshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON)
	if err != nil {
		return nil, err
	}
	args["matchProperties"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "setProperties", ec.unmarshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON)
	if err != nil {
		return nil, err
	}
	args["setProperties"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_mergeRelationship_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "startNodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["startNodeId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "endNodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["endNodeId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "type", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["type"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "properties", ec.unmarshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON)
	if err != nil {
		return nil, err
	}
	args["properties"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_triggerEmbedding_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "regenerate", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["regenerate"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateNode_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateNodeInput2githubcomornerydnornicdbpkggraphqlmodelsUpdateNodeInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRelationship_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateRelationshipInput2githubcomornerydnornicdbpkggraphqlmodelsUpdateRelationshipInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Node_incoming_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "types", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["types"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Node_neighbors_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "direction", ec.unmarshalORelationshipDirection2githubcomornerydnornicdbpkggraphqlmodelsRelationshipDirection)
	if err != nil {
		return nil, err
	}
	args["direction"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "relationshipTypes", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["relationshipTypes"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "labels", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["labels"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg3
	return args, nil
}

func (ec *executionContext) field_Node_outgoing_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "types", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["types"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Node_relationships_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "types", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["types"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "direction", ec.unmarshalORelationshipDirection2githubcomornerydnornicdbpkggraphqlmodelsRelationshipDirection)
	if err != nil {
		return nil, err
	}
	args["direction"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_Node_similar_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "threshold", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["threshold"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_allNodes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "labels", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["labels"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_allPaths_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "startNodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["startNodeId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "endNodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["endNodeId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "maxDepth", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["maxDepth"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_allRelationships_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "types", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["types"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_cypher_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCypherInput2githubcomornerydnornicdbpkggraphqlmodelsCypherInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_neighborhood_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "nodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["nodeId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "depth", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["depth"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "relationshipTypes", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["relationshipTypes"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "labels", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["labels"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_nodeCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "label", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["label"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodesByLabel_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "label", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["label"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	args := map[string]any{}
	// ids is optional, so check if it's provided
	if val, ok := rawArgs["ids"]; ok && val != nil {
		arg0, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalNID2string)
		if err != nil {
			return nil, err
		}
		args["ids"] = arg0
	} else {
		args["ids"] = nil
	}
	return args, nil
}

func (ec *executionContext) field_Query_relationshipCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "type", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["type"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_relationship_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_relationshipsBetween_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "startNodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["startNodeId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "endNodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["endNodeId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_relationshipsByType_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "type", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["type"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_searchByProperty_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "key", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["key"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "value", ec.unmarshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON)
	if err != nil {
		return nil, err
	}
	args["value"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "labels", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["labels"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_search_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "query", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["query"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalOSearchOptions2githubcomornerydnornicdbpkggraphqlmodelsSearchOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_shortestPath_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "startNodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["startNodeId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "endNodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["endNodeId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "maxDepth", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["maxDepth"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "relationshipTypes", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["relationshipTypes"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_similar_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "nodeId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["nodeId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "threshold", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["threshold"] = arg2
	return args, nil
}

func (ec *executionContext) field_Subscription_nodeCreated_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "labels", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["labels"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_nodeDeleted_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "labels", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["labels"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_nodeUpdated_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalOID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "labels", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["labels"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_relationshipCreated_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "types", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["types"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_relationshipDeleted_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "types", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["types"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_relationshipUpdated_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalOID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "types", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["types"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_searchStream_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "query", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["query"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalOSearchOptions2githubcomornerydnornicdbpkggraphqlmodelsSearchOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg1
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _BulkCreateResult_created(ctx context.Context, field graphql.CollectedField, obj *models.BulkCreateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BulkCreateResult_created,
		func(ctx context.Context) (any, error) {
			return obj.Created, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BulkCreateResult_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkCreateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BulkCreateResult_skipped(ctx context.Context, field graphql.CollectedField, obj *models.BulkCreateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BulkCreateResult_skipped,
		func(ctx context.Context) (any, error) {
			return obj.Skipped, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BulkCreateResult_skipped(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkCreateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BulkCreateResult_errors(ctx context.Context, field graphql.CollectedField, obj *models.BulkCreateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BulkCreateResult_errors,
		func(ctx context.Context) (any, error) {
			return obj.Errors, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BulkCreateResult_errors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkCreateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BulkDeleteResult_deleted(ctx context.Context, field graphql.CollectedField, obj *models.BulkDeleteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BulkDeleteResult_deleted,
		func(ctx context.Context) (any, error) {
			return obj.Deleted, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BulkDeleteResult_deleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BulkDeleteResult_notFound(ctx context.Context, field graphql.CollectedField, obj *models.BulkDeleteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BulkDeleteResult_notFound,
		func(ctx context.Context) (any, error) {
			return obj.NotFound, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BulkDeleteResult_notFound(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BulkDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherResult_columns(ctx context.Context, field graphql.CollectedField, obj *models.CypherResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherResult_columns,
		func(ctx context.Context) (any, error) {
			return obj.Columns, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherResult_columns(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherResult_rows(ctx context.Context, field graphql.CollectedField, obj *models.CypherResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherResult_rows,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.CypherResult().Rows(ctx, obj)
		},
		nil,
		ec.marshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherResult_rows(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherResult_rowCount(ctx context.Context, field graphql.CollectedField, obj *models.CypherResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherResult_rowCount,
		func(ctx context.Context) (any, error) {
			return obj.RowCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherResult_rowCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherResult_stats(ctx context.Context, field graphql.CollectedField, obj *models.CypherResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherResult_stats,
		func(ctx context.Context) (any, error) {
			return obj.Stats, nil
		},
		nil,
		ec.marshalOCypherStats2githubcomornerydnornicdbpkggraphqlmodelsCypherStats,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CypherResult_stats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodesCreated":
				return ec.fieldContext_CypherStats_nodesCreated(ctx, field)
			case "nodesDeleted":
				return ec.fieldContext_CypherStats_nodesDeleted(ctx, field)
			case "relationshipsCreated":
				return ec.fieldContext_CypherStats_relationshipsCreated(ctx, field)
			case "relationshipsDeleted":
				return ec.fieldContext_CypherStats_relationshipsDeleted(ctx, field)
			case "propertiesSet":
				return ec.fieldContext_CypherStats_propertiesSet(ctx, field)
			case "labelsAdded":
				return ec.fieldContext_CypherStats_labelsAdded(ctx, field)
			case "labelsRemoved":
				return ec.fieldContext_CypherStats_labelsRemoved(ctx, field)
			case "containsUpdates":
				return ec.fieldContext_CypherStats_containsUpdates(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CypherStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherResult_executionTimeMs(ctx context.Context, field graphql.CollectedField, obj *models.CypherResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherResult_executionTimeMs,
		func(ctx context.Context) (any, error) {
			return obj.ExecutionTimeMs, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherResult_executionTimeMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherStats_nodesCreated(ctx context.Context, field graphql.CollectedField, obj *models.CypherStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherStats_nodesCreated,
		func(ctx context.Context) (any, error) {
			return obj.NodesCreated, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherStats_nodesCreated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherStats_nodesDeleted(ctx context.Context, field graphql.CollectedField, obj *models.CypherStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherStats_nodesDeleted,
		func(ctx context.Context) (any, error) {
			return obj.NodesDeleted, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherStats_nodesDeleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherStats_relationshipsCreated(ctx context.Context, field graphql.CollectedField, obj *models.CypherStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherStats_relationshipsCreated,
		func(ctx context.Context) (any, error) {
			return obj.RelationshipsCreated, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherStats_relationshipsCreated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherStats_relationshipsDeleted(ctx context.Context, field graphql.CollectedField, obj *models.CypherStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherStats_relationshipsDeleted,
		func(ctx context.Context) (any, error) {
			return obj.RelationshipsDeleted, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherStats_relationshipsDeleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherStats_propertiesSet(ctx context.Context, field graphql.CollectedField, obj *models.CypherStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherStats_propertiesSet,
		func(ctx context.Context) (any, error) {
			return obj.PropertiesSet, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherStats_propertiesSet(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherStats_labelsAdded(ctx context.Context, field graphql.CollectedField, obj *models.CypherStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherStats_labelsAdded,
		func(ctx context.Context) (any, error) {
			return obj.LabelsAdded, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherStats_labelsAdded(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherStats_labelsRemoved(ctx context.Context, field graphql.CollectedField, obj *models.CypherStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherStats_labelsRemoved,
		func(ctx context.Context) (any, error) {
			return obj.LabelsRemoved, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherStats_labelsRemoved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CypherStats_containsUpdates(ctx context.Context, field graphql.CollectedField, obj *models.CypherStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CypherStats_containsUpdates,
		func(ctx context.Context) (any, error) {
			return obj.ContainsUpdates, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CypherStats_containsUpdates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CypherStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseStats_nodeCount(ctx context.Context, field graphql.CollectedField, obj *models.DatabaseStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DatabaseStats_nodeCount,
		func(ctx context.Context) (any, error) {
			return obj.NodeCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DatabaseStats_nodeCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseStats_relationshipCount(ctx context.Context, field graphql.CollectedField, obj *models.DatabaseStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DatabaseStats_relationshipCount,
		func(ctx context.Context) (any, error) {
			return obj.RelationshipCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DatabaseStats_relationshipCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseStats_labels(ctx context.Context, field graphql.CollectedField, obj *models.DatabaseStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DatabaseStats_labels,
		func(ctx context.Context) (any, error) {
			return obj.Labels, nil
		},
		nil,
		ec.marshalNLabelStats2githubcomornerydnornicdbpkggraphqlmodelsLabelStats,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DatabaseStats_labels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "label":
				return ec.fieldContext_LabelStats_label(ctx, field)
			case "count":
				return ec.fieldContext_LabelStats_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseStats_relationshipTypes(ctx context.Context, field graphql.CollectedField, obj *models.DatabaseStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DatabaseStats_relationshipTypes,
		func(ctx context.Context) (any, error) {
			return obj.RelationshipTypes, nil
		},
		nil,
		ec.marshalNRelationshipTypeStats2githubcomornerydnornicdbpkggraphqlmodelsRelationshipTypeStats,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DatabaseStats_relationshipTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_RelationshipTypeStats_type(ctx, field)
			case "count":
				return ec.fieldContext_RelationshipTypeStats_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RelationshipTypeStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseStats_embeddedNodeCount(ctx context.Context, field graphql.CollectedField, obj *models.DatabaseStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DatabaseStats_embeddedNodeCount,
		func(ctx context.Context) (any, error) {
			return obj.EmbeddedNodeCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DatabaseStats_embeddedNodeCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseStats_uptimeSeconds(ctx context.Context, field graphql.CollectedField, obj *models.DatabaseStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DatabaseStats_uptimeSeconds,
		func(ctx context.Context) (any, error) {
			return obj.UptimeSeconds, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DatabaseStats_uptimeSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseStats_memoryUsageBytes(ctx context.Context, field graphql.CollectedField, obj *models.DatabaseStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DatabaseStats_memoryUsageBytes,
		func(ctx context.Context) (any, error) {
			return obj.MemoryUsageBytes, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DatabaseStats_memoryUsageBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DecayResult_nodesProcessed(ctx context.Context, field graphql.CollectedField, obj *models.DecayResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DecayResult_nodesProcessed,
		func(ctx context.Context) (any, error) {
			return obj.NodesProcessed, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DecayResult_nodesProcessed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DecayResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DecayResult_nodesDecayed(ctx context.Context, field graphql.CollectedField, obj *models.DecayResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DecayResult_nodesDecayed,
		func(ctx context.Context) (any, error) {
			return obj.NodesDecayed, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DecayResult_nodesDecayed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DecayResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DecayResult_averageDecayScore(ctx context.Context, field graphql.CollectedField, obj *models.DecayResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DecayResult_averageDecayScore,
		func(ctx context.Context) (any, error) {
			return obj.AverageDecayScore, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DecayResult_averageDecayScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DecayResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmbeddingStatus_pending(ctx context.Context, field graphql.CollectedField, obj *models.EmbeddingStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EmbeddingStatus_pending,
		func(ctx context.Context) (any, error) {
			return obj.Pending, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EmbeddingStatus_pending(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbeddingStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmbeddingStatus_embedded(ctx context.Context, field graphql.CollectedField, obj *models.EmbeddingStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EmbeddingStatus_embedded,
		func(ctx context.Context) (any, error) {
			return obj.Embedded, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EmbeddingStatus_embedded(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbeddingStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmbeddingStatus_total(ctx context.Context, field graphql.CollectedField, obj *models.EmbeddingStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EmbeddingStatus_total,
		func(ctx context.Context) (any, error) {
			return obj.Total, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EmbeddingStatus_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbeddingStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmbeddingStatus_workerRunning(ctx context.Context, field graphql.CollectedField, obj *models.EmbeddingStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EmbeddingStatus_workerRunning,
		func(ctx context.Context) (any, error) {
			return obj.WorkerRunning, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EmbeddingStatus_workerRunning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbeddingStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphSchema_nodeLabels(ctx context.Context, field graphql.CollectedField, obj *models.GraphSchema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GraphSchema_nodeLabels,
		func(ctx context.Context) (any, error) {
			return obj.NodeLabels, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GraphSchema_nodeLabels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphSchema",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphSchema_relationshipTypes(ctx context.Context, field graphql.CollectedField, obj *models.GraphSchema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GraphSchema_relationshipTypes,
		func(ctx context.Context) (any, error) {
			return obj.RelationshipTypes, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GraphSchema_relationshipTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphSchema",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphSchema_nodePropertyKeys(ctx context.Context, field graphql.CollectedField, obj *models.GraphSchema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GraphSchema_nodePropertyKeys,
		func(ctx context.Context) (any, error) {
			return obj.NodePropertyKeys, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GraphSchema_nodePropertyKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphSchema",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphSchema_relationshipPropertyKeys(ctx context.Context, field graphql.CollectedField, obj *models.GraphSchema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GraphSchema_relationshipPropertyKeys,
		func(ctx context.Context) (any, error) {
			return obj.RelationshipPropertyKeys, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GraphSchema_relationshipPropertyKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphSchema",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphSchema_constraints(ctx context.Context, field graphql.CollectedField, obj *models.GraphSchema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GraphSchema_constraints,
		func(ctx context.Context) (any, error) {
			return obj.Constraints, nil
		},
		nil,
		ec.marshalNSchemaConstraint2githubcomornerydnornicdbpkggraphqlmodelsSchemaConstraint,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GraphSchema_constraints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphSchema",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SchemaConstraint_name(ctx, field)
			case "type":
				return ec.fieldContext_SchemaConstraint_type(ctx, field)
			case "entityType":
				return ec.fieldContext_SchemaConstraint_entityType(ctx, field)
			case "labelsOrTypes":
				return ec.fieldContext_SchemaConstraint_labelsOrTypes(ctx, field)
			case "properties":
				return ec.fieldContext_SchemaConstraint_properties(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SchemaConstraint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelStats_label(ctx context.Context, field graphql.CollectedField, obj *models.LabelStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LabelStats_label,
		func(ctx context.Context) (any, error) {
			return obj.Label, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LabelStats_label(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelStats_count(ctx context.Context, field graphql.CollectedField, obj *models.LabelStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LabelStats_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LabelStats_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createNode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createNode,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateNode(ctx, fc.Args["input"].(models.CreateNodeInput))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createNode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createNode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateNode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateNode,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateNode(ctx, fc.Args["input"].(models.UpdateNodeInput))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateNode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateNode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteNode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteNode,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteNode(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteNode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteNode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateNodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateNodes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateNodes(ctx, fc.Args["input"].(models.BulkCreateNodesInput))
		},
		nil,
		ec.marshalNBulkCreateResult2githubcomornerydnornicdbpkggraphqlmodelsBulkCreateResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateNodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "created":
				return ec.fieldContext_BulkCreateResult_created(ctx, field)
			case "skipped":
				return ec.fieldContext_BulkCreateResult_skipped(ctx, field)
			case "errors":
				return ec.fieldContext_BulkCreateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkCreateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateNodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteNodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteNodes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteNodes(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcomornerydnornicdbpkggraphqlmodelsBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteNodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deleted":
				return ec.fieldContext_BulkDeleteResult_deleted(ctx, field)
			case "notFound":
				return ec.fieldContext_BulkDeleteResult_notFound(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteNodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_mergeNode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_mergeNode,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().MergeNode(ctx, fc.Args["labels"].([]string), fc.Args["matchProperties"].(models.JSON), fc.Args["setProperties"].(models.JSON))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_mergeNode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_mergeNode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createRelationship(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createRelationship,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateRelationship(ctx, fc.Args["input"].(models.CreateRelationshipInput))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createRelationship(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createRelationship_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRelationship(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateRelationship,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateRelationship(ctx, fc.Args["input"].(models.UpdateRelationshipInput))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateRelationship(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRelationship_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteRelationship(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteRelationship,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteRelationship(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteRelationship(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteRelationship_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkCreateRelationships(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkCreateRelationships,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkCreateRelationships(ctx, fc.Args["input"].(models.BulkCreateRelationshipsInput))
		},
		nil,
		ec.marshalNBulkCreateResult2githubcomornerydnornicdbpkggraphqlmodelsBulkCreateResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkCreateRelationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "created":
				return ec.fieldContext_BulkCreateResult_created(ctx, field)
			case "skipped":
				return ec.fieldContext_BulkCreateResult_skipped(ctx, field)
			case "errors":
				return ec.fieldContext_BulkCreateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkCreateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkCreateRelationships_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bulkDeleteRelationships(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bulkDeleteRelationships,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BulkDeleteRelationships(ctx, fc.Args["ids"].([]string))
		},
		nil,
		ec.marshalNBulkDeleteResult2githubcomornerydnornicdbpkggraphqlmodelsBulkDeleteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bulkDeleteRelationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deleted":
				return ec.fieldContext_BulkDeleteResult_deleted(ctx, field)
			case "notFound":
				return ec.fieldContext_BulkDeleteResult_notFound(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BulkDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bulkDeleteRelationships_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_mergeRelationship(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_mergeRelationship,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().MergeRelationship(ctx, fc.Args["startNodeId"].(string), fc.Args["endNodeId"].(string), fc.Args["type"].(string), fc.Args["properties"].(models.JSON))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_mergeRelationship(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_mergeRelationship_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_executeCypher(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_executeCypher,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ExecuteCypher(ctx, fc.Args["input"].(models.CypherInput))
		},
		nil,
		ec.marshalNCypherResult2githubcomornerydnornicdbpkggraphqlmodelsCypherResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_executeCypher(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "columns":
				return ec.fieldContext_CypherResult_columns(ctx, field)
			case "rows":
				return ec.fieldContext_CypherResult_rows(ctx, field)
			case "rowCount":
				return ec.fieldContext_CypherResult_rowCount(ctx, field)
			case "stats":
				return ec.fieldContext_CypherResult_stats(ctx, field)
			case "executionTimeMs":
				return ec.fieldContext_CypherResult_executionTimeMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CypherResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_executeCypher_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_triggerEmbedding(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_triggerEmbedding,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().TriggerEmbedding(ctx, fc.Args["regenerate"].(*bool))
		},
		nil,
		ec.marshalNEmbeddingStatus2githubcomornerydnornicdbpkggraphqlmodelsEmbeddingStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_triggerEmbedding(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pending":
				return ec.fieldContext_EmbeddingStatus_pending(ctx, field)
			case "embedded":
				return ec.fieldContext_EmbeddingStatus_embedded(ctx, field)
			case "total":
				return ec.fieldContext_EmbeddingStatus_total(ctx, field)
			case "workerRunning":
				return ec.fieldContext_EmbeddingStatus_workerRunning(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EmbeddingStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_triggerEmbedding_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rebuildSearchIndex(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_rebuildSearchIndex,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().RebuildSearchIndex(ctx)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_rebuildSearchIndex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_runDecay(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_runDecay,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().RunDecay(ctx)
		},
		nil,
		ec.marshalNDecayResult2githubcomornerydnornicdbpkggraphqlmodelsDecayResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_runDecay(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodesProcessed":
				return ec.fieldContext_DecayResult_nodesProcessed(ctx, field)
			case "nodesDecayed":
				return ec.fieldContext_DecayResult_nodesDecayed(ctx, field)
			case "averageDecayScore":
				return ec.fieldContext_DecayResult_averageDecayScore(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DecayResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_clearAll(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_clearAll,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ClearAll(ctx, fc.Args["confirmPhrase"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_clearAll(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_clearAll_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Node_id(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_internalId(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_internalId,
		func(ctx context.Context) (any, error) {
			return obj.InternalID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_internalId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_labels(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_labels,
		func(ctx context.Context) (any, error) {
			return obj.Labels, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_labels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_properties(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_properties,
		func(ctx context.Context) (any, error) {
			return obj.Properties, nil
		},
		nil,
		ec.marshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_properties(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalODateTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Node_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalODateTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Node_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_decayScore(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_decayScore,
		func(ctx context.Context) (any, error) {
			return obj.DecayScore, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Node_decayScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_lastAccessed(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_lastAccessed,
		func(ctx context.Context) (any, error) {
			return obj.LastAccessed, nil
		},
		nil,
		ec.marshalODateTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Node_lastAccessed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_accessCount(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_accessCount,
		func(ctx context.Context) (any, error) {
			return obj.AccessCount, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Node_accessCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_hasEmbedding(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_hasEmbedding,
		func(ctx context.Context) (any, error) {
			return obj.HasEmbedding, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_hasEmbedding(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_embeddingDimensions(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_embeddingDimensions,
		func(ctx context.Context) (any, error) {
			return obj.EmbeddingDimensions, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_embeddingDimensions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_relationships(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_relationships,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Node().Relationships(ctx, obj, fc.Args["types"].([]string), fc.Args["direction"].(*models.RelationshipDirection), fc.Args["limit"].(*int))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_relationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Node_relationships_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Node_outgoing(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_outgoing,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Node().Outgoing(ctx, obj, fc.Args["types"].([]string), fc.Args["limit"].(*int))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_outgoing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Node_outgoing_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Node_incoming(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_incoming,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Node().Incoming(ctx, obj, fc.Args["types"].([]string), fc.Args["limit"].(*int))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_incoming(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Node_incoming_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Node_neighbors(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_neighbors,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Node().Neighbors(ctx, obj, fc.Args["direction"].(*models.RelationshipDirection), fc.Args["relationshipTypes"].([]string), fc.Args["labels"].([]string), fc.Args["limit"].(*int))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_neighbors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Node_neighbors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Node_similar(ctx context.Context, field graphql.CollectedField, obj *models.Node) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Node_similar,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Node().Similar(ctx, obj, fc.Args["limit"].(*int), fc.Args["threshold"].(*float64))
		},
		nil,
		ec.marshalNSimilarNode2githubcomornerydnornicdbpkggraphqlmodelsSimilarNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Node_similar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SimilarNode_node(ctx, field)
			case "similarity":
				return ec.fieldContext_SimilarNode_similarity(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SimilarNode", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Node_similar_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_node,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Node(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalONode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_nodes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			var ids []string
			if fc.Args["ids"] != nil {
				ids = fc.Args["ids"].([]string)
			}
			return ec.resolvers.Query().Nodes(ctx, ids)
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_allNodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_allNodes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().AllNodes(ctx, fc.Args["labels"].([]string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_allNodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_allNodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodesByLabel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_nodesByLabel,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().NodesByLabel(ctx, fc.Args["label"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_nodesByLabel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodesByLabel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodeCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_nodeCount,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().NodeCount(ctx, fc.Args["label"].(*string))
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_nodeCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodeCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_relationship(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_relationship,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Relationship(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalORelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_relationship(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_relationship_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_allRelationships(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_allRelationships,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().AllRelationships(ctx, fc.Args["types"].([]string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_allRelationships(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_allRelationships_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_relationshipsByType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_relationshipsByType,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().RelationshipsByType(ctx, fc.Args["type"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_relationshipsByType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_relationshipsByType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_relationshipsBetween(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_relationshipsBetween,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().RelationshipsBetween(ctx, fc.Args["startNodeId"].(string), fc.Args["endNodeId"].(string))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_relationshipsBetween(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_relationshipsBetween_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_relationshipCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_relationshipCount,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().RelationshipCount(ctx, fc.Args["type"].(*string))
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_relationshipCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_relationshipCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_search(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_search,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Search(ctx, fc.Args["query"].(string), fc.Args["options"].(*models.SearchOptions))
		},
		nil,
		ec.marshalNSearchResponse2githubcomornerydnornicdbpkggraphqlmodelsSearchResponse,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_search(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "results":
				return ec.fieldContext_SearchResponse_results(ctx, field)
			case "totalCount":
				return ec.fieldContext_SearchResponse_totalCount(ctx, field)
			case "method":
				return ec.fieldContext_SearchResponse_method(ctx, field)
			case "executionTimeMs":
				return ec.fieldContext_SearchResponse_executionTimeMs(ctx, field)
			case "vectorSearchUsed":
				return ec.fieldContext_SearchResponse_vectorSearchUsed(ctx, field)
			case "bm25SearchUsed":
				return ec.fieldContext_SearchResponse_bm25SearchUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_search_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_similar(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_similar,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Similar(ctx, fc.Args["nodeId"].(string), fc.Args["limit"].(*int), fc.Args["threshold"].(*float64))
		},
		nil,
		ec.marshalNSimilarNode2githubcomornerydnornicdbpkggraphqlmodelsSimilarNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_similar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SimilarNode_node(ctx, field)
			case "similarity":
				return ec.fieldContext_SimilarNode_similarity(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SimilarNode", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_similar_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchByProperty(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_searchByProperty,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SearchByProperty(ctx, fc.Args["key"].(string), fc.Args["value"].(models.JSON), fc.Args["labels"].([]string), fc.Args["limit"].(*int))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_searchByProperty(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchByProperty_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cypher(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_cypher,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Cypher(ctx, fc.Args["input"].(models.CypherInput))
		},
		nil,
		ec.marshalNCypherResult2githubcomornerydnornicdbpkggraphqlmodelsCypherResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_cypher(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "columns":
				return ec.fieldContext_CypherResult_columns(ctx, field)
			case "rows":
				return ec.fieldContext_CypherResult_rows(ctx, field)
			case "rowCount":
				return ec.fieldContext_CypherResult_rowCount(ctx, field)
			case "stats":
				return ec.fieldContext_CypherResult_stats(ctx, field)
			case "executionTimeMs":
				return ec.fieldContext_CypherResult_executionTimeMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CypherResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cypher_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_stats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_stats,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Stats(ctx)
		},
		nil,
		ec.marshalNDatabaseStats2githubcomornerydnornicdbpkggraphqlmodelsDatabaseStats,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_stats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodeCount":
				return ec.fieldContext_DatabaseStats_nodeCount(ctx, field)
			case "relationshipCount":
				return ec.fieldContext_DatabaseStats_relationshipCount(ctx, field)
			case "labels":
				return ec.fieldContext_DatabaseStats_labels(ctx, field)
			case "relationshipTypes":
				return ec.fieldContext_DatabaseStats_relationshipTypes(ctx, field)
			case "embeddedNodeCount":
				return ec.fieldContext_DatabaseStats_embeddedNodeCount(ctx, field)
			case "uptimeSeconds":
				return ec.fieldContext_DatabaseStats_uptimeSeconds(ctx, field)
			case "memoryUsageBytes":
				return ec.fieldContext_DatabaseStats_memoryUsageBytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatabaseStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_schema,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Schema(ctx)
		},
		nil,
		ec.marshalNGraphSchema2githubcomornerydnornicdbpkggraphqlmodelsGraphSchema,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodeLabels":
				return ec.fieldContext_GraphSchema_nodeLabels(ctx, field)
			case "relationshipTypes":
				return ec.fieldContext_GraphSchema_relationshipTypes(ctx, field)
			case "nodePropertyKeys":
				return ec.fieldContext_GraphSchema_nodePropertyKeys(ctx, field)
			case "relationshipPropertyKeys":
				return ec.fieldContext_GraphSchema_relationshipPropertyKeys(ctx, field)
			case "constraints":
				return ec.fieldContext_GraphSchema_constraints(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GraphSchema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_labels(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_labels,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Labels(ctx)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_labels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_relationshipTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_relationshipTypes,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().RelationshipTypes(ctx)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_relationshipTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_shortestPath(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_shortestPath,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ShortestPath(ctx, fc.Args["startNodeId"].(string), fc.Args["endNodeId"].(string), fc.Args["maxDepth"].(*int), fc.Args["relationshipTypes"].([]string))
		},
		nil,
		ec.marshalONode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_shortestPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_shortestPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_allPaths(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_allPaths,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().AllPaths(ctx, fc.Args["startNodeId"].(string), fc.Args["endNodeId"].(string), fc.Args["maxDepth"].(*int), fc.Args["limit"].(*int))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_allPaths(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_allPaths_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_neighborhood(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_neighborhood,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Neighborhood(ctx, fc.Args["nodeId"].(string), fc.Args["depth"].(*int), fc.Args["relationshipTypes"].([]string), fc.Args["labels"].([]string), fc.Args["limit"].(*int))
		},
		nil,
		ec.marshalNSubgraph2githubcomornerydnornicdbpkggraphqlmodelsSubgraph,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_neighborhood(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nodes":
				return ec.fieldContext_Subgraph_nodes(ctx, field)
			case "relationships":
				return ec.fieldContext_Subgraph_relationships(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Subgraph", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_neighborhood_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_id(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Relationship_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_internalId(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_internalId,
		func(ctx context.Context) (any, error) {
			return obj.InternalID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Relationship_internalId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_type(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Relationship_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_startNode(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_startNode,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Relationship().StartNode(ctx, obj)
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Relationship_startNode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_endNode(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_endNode,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Relationship().EndNode(ctx, obj)
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Relationship_endNode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_properties(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_properties,
		func(ctx context.Context) (any, error) {
			return obj.Properties, nil
		},
		nil,
		ec.marshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Relationship_properties(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalODateTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Relationship_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalODateTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Relationship_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_confidence(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_confidence,
		func(ctx context.Context) (any, error) {
			return obj.Confidence, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Relationship_confidence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Relationship_autoGenerated(ctx context.Context, field graphql.CollectedField, obj *models.Relationship) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Relationship_autoGenerated,
		func(ctx context.Context) (any, error) {
			return obj.AutoGenerated, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Relationship_autoGenerated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Relationship",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelationshipTypeStats_type(ctx context.Context, field graphql.CollectedField, obj *models.RelationshipTypeStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RelationshipTypeStats_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RelationshipTypeStats_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelationshipTypeStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RelationshipTypeStats_count(ctx context.Context, field graphql.CollectedField, obj *models.RelationshipTypeStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RelationshipTypeStats_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RelationshipTypeStats_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RelationshipTypeStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchemaConstraint_name(ctx context.Context, field graphql.CollectedField, obj *models.SchemaConstraint) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchemaConstraint_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SchemaConstraint_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchemaConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchemaConstraint_type(ctx context.Context, field graphql.CollectedField, obj *models.SchemaConstraint) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchemaConstraint_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SchemaConstraint_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchemaConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchemaConstraint_entityType(ctx context.Context, field graphql.CollectedField, obj *models.SchemaConstraint) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchemaConstraint_entityType,
		func(ctx context.Context) (any, error) {
			return obj.EntityType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SchemaConstraint_entityType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchemaConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchemaConstraint_labelsOrTypes(ctx context.Context, field graphql.CollectedField, obj *models.SchemaConstraint) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchemaConstraint_labelsOrTypes,
		func(ctx context.Context) (any, error) {
			return obj.LabelsOrTypes, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SchemaConstraint_labelsOrTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchemaConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchemaConstraint_properties(ctx context.Context, field graphql.CollectedField, obj *models.SchemaConstraint) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchemaConstraint_properties,
		func(ctx context.Context) (any, error) {
			return obj.Properties, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SchemaConstraint_properties(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchemaConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_results(ctx context.Context, field graphql.CollectedField, obj *models.SearchResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResponse_results,
		func(ctx context.Context) (any, error) {
			return obj.Results, nil
		},
		nil,
		ec.marshalNSearchResult2githubcomornerydnornicdbpkggraphqlmodelsSearchResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResponse_results(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SearchResult_node(ctx, field)
			case "score":
				return ec.fieldContext_SearchResult_score(ctx, field)
			case "rrfScore":
				return ec.fieldContext_SearchResult_rrfScore(ctx, field)
			case "vectorScore":
				return ec.fieldContext_SearchResult_vectorScore(ctx, field)
			case "bm25Score":
				return ec.fieldContext_SearchResult_bm25Score(ctx, field)
			case "vectorRank":
				return ec.fieldContext_SearchResult_vectorRank(ctx, field)
			case "bm25Rank":
				return ec.fieldContext_SearchResult_bm25Rank(ctx, field)
			case "foundBy":
				return ec.fieldContext_SearchResult_foundBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.SearchResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResponse_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResponse_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_method(ctx context.Context, field graphql.CollectedField, obj *models.SearchResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResponse_method,
		func(ctx context.Context) (any, error) {
			return obj.Method, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResponse_method(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_executionTimeMs(ctx context.Context, field graphql.CollectedField, obj *models.SearchResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResponse_executionTimeMs,
		func(ctx context.Context) (any, error) {
			return obj.ExecutionTimeMs, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResponse_executionTimeMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_vectorSearchUsed(ctx context.Context, field graphql.CollectedField, obj *models.SearchResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResponse_vectorSearchUsed,
		func(ctx context.Context) (any, error) {
			return obj.VectorSearchUsed, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResponse_vectorSearchUsed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_bm25SearchUsed(ctx context.Context, field graphql.CollectedField, obj *models.SearchResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResponse_bm25SearchUsed,
		func(ctx context.Context) (any, error) {
			return obj.BM25SearchUsed, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResponse_bm25SearchUsed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResult_node(ctx context.Context, field graphql.CollectedField, obj *models.SearchResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResult_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResult_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResult_score(ctx context.Context, field graphql.CollectedField, obj *models.SearchResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResult_score,
		func(ctx context.Context) (any, error) {
			return obj.Score, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResult_score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResult_rrfScore(ctx context.Context, field graphql.CollectedField, obj *models.SearchResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResult_rrfScore,
		func(ctx context.Context) (any, error) {
			return obj.RRFScore, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SearchResult_rrfScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResult_vectorScore(ctx context.Context, field graphql.CollectedField, obj *models.SearchResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResult_vectorScore,
		func(ctx context.Context) (any, error) {
			return obj.VectorScore, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SearchResult_vectorScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResult_bm25Score(ctx context.Context, field graphql.CollectedField, obj *models.SearchResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResult_bm25Score,
		func(ctx context.Context) (any, error) {
			return obj.BM25Score, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SearchResult_bm25Score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResult_vectorRank(ctx context.Context, field graphql.CollectedField, obj *models.SearchResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResult_vectorRank,
		func(ctx context.Context) (any, error) {
			return obj.VectorRank, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SearchResult_vectorRank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResult_bm25Rank(ctx context.Context, field graphql.CollectedField, obj *models.SearchResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResult_bm25Rank,
		func(ctx context.Context) (any, error) {
			return obj.BM25Rank, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SearchResult_bm25Rank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResult_foundBy(ctx context.Context, field graphql.CollectedField, obj *models.SearchResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchResult_foundBy,
		func(ctx context.Context) (any, error) {
			return obj.FoundBy, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchResult_foundBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SimilarNode_node(ctx context.Context, field graphql.CollectedField, obj *models.SimilarNode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SimilarNode_node,
		func(ctx context.Context) (any, error) {
			return obj.Node, nil
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SimilarNode_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SimilarNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SimilarNode_similarity(ctx context.Context, field graphql.CollectedField, obj *models.SimilarNode) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SimilarNode_similarity,
		func(ctx context.Context) (any, error) {
			return obj.Similarity, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SimilarNode_similarity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SimilarNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subgraph_nodes(ctx context.Context, field graphql.CollectedField, obj *models.Subgraph) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subgraph_nodes,
		func(ctx context.Context) (any, error) {
			return obj.Nodes, nil
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subgraph_nodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subgraph",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subgraph_relationships(ctx context.Context, field graphql.CollectedField, obj *models.Subgraph) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subgraph_relationships,
		func(ctx context.Context) (any, error) {
			return obj.Relationships, nil
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subgraph_relationships(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subgraph",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_nodeCreated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_nodeCreated,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().NodeCreated(ctx, fc.Args["labels"].([]string))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_nodeCreated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_nodeCreated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_nodeUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_nodeUpdated,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().NodeUpdated(ctx, fc.Args["id"].(*string), fc.Args["labels"].([]string))
		},
		nil,
		ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_nodeUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Node_internalId(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "properties":
				return ec.fieldContext_Node_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Node_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Node_updatedAt(ctx, field)
			case "decayScore":
				return ec.fieldContext_Node_decayScore(ctx, field)
			case "lastAccessed":
				return ec.fieldContext_Node_lastAccessed(ctx, field)
			case "accessCount":
				return ec.fieldContext_Node_accessCount(ctx, field)
			case "hasEmbedding":
				return ec.fieldContext_Node_hasEmbedding(ctx, field)
			case "embeddingDimensions":
				return ec.fieldContext_Node_embeddingDimensions(ctx, field)
			case "relationships":
				return ec.fieldContext_Node_relationships(ctx, field)
			case "outgoing":
				return ec.fieldContext_Node_outgoing(ctx, field)
			case "incoming":
				return ec.fieldContext_Node_incoming(ctx, field)
			case "neighbors":
				return ec.fieldContext_Node_neighbors(ctx, field)
			case "similar":
				return ec.fieldContext_Node_similar(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_nodeUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_nodeDeleted(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_nodeDeleted,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().NodeDeleted(ctx, fc.Args["labels"].([]string))
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_nodeDeleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_nodeDeleted_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_relationshipCreated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_relationshipCreated,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().RelationshipCreated(ctx, fc.Args["types"].([]string))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_relationshipCreated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_relationshipCreated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_relationshipUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_relationshipUpdated,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().RelationshipUpdated(ctx, fc.Args["id"].(*string), fc.Args["types"].([]string))
		},
		nil,
		ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_relationshipUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Relationship_id(ctx, field)
			case "internalId":
				return ec.fieldContext_Relationship_internalId(ctx, field)
			case "type":
				return ec.fieldContext_Relationship_type(ctx, field)
			case "startNode":
				return ec.fieldContext_Relationship_startNode(ctx, field)
			case "endNode":
				return ec.fieldContext_Relationship_endNode(ctx, field)
			case "properties":
				return ec.fieldContext_Relationship_properties(ctx, field)
			case "createdAt":
				return ec.fieldContext_Relationship_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Relationship_updatedAt(ctx, field)
			case "confidence":
				return ec.fieldContext_Relationship_confidence(ctx, field)
			case "autoGenerated":
				return ec.fieldContext_Relationship_autoGenerated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Relationship", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_relationshipUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_relationshipDeleted(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_relationshipDeleted,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().RelationshipDeleted(ctx, fc.Args["types"].([]string))
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_relationshipDeleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_relationshipDeleted_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_searchStream(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_searchStream,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().SearchStream(ctx, fc.Args["query"].(string), fc.Args["options"].(*models.SearchOptions))
		},
		nil,
		ec.marshalNSearchResult2githubcomornerydnornicdbpkggraphqlmodelsSearchResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_searchStream(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SearchResult_node(ctx, field)
			case "score":
				return ec.fieldContext_SearchResult_score(ctx, field)
			case "rrfScore":
				return ec.fieldContext_SearchResult_rrfScore(ctx, field)
			case "vectorScore":
				return ec.fieldContext_SearchResult_vectorScore(ctx, field)
			case "bm25Score":
				return ec.fieldContext_SearchResult_bm25Score(ctx, field)
			case "vectorRank":
				return ec.fieldContext_SearchResult_vectorRank(ctx, field)
			case "bm25Rank":
				return ec.fieldContext_SearchResult_bm25Rank(ctx, field)
			case "foundBy":
				return ec.fieldContext_SearchResult_foundBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_searchStream_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBulkCreateNodesInput(ctx context.Context, obj any) (models.BulkCreateNodesInput, error) {
	var it models.BulkCreateNodesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["skipDuplicates"]; !present {
		asMap["skipDuplicates"] = false
	}

	fieldsInOrder := [...]string{"nodes", "skipDuplicates"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "nodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nodes"))
			data, err := ec.unmarshalNCreateNodeInput2githubcomornerydnornicdbpkggraphqlmodelsCreateNodeInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nodes = data
		case "skipDuplicates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skipDuplicates"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkipDuplicates = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBulkCreateRelationshipsInput(ctx context.Context, obj any) (models.BulkCreateRelationshipsInput, error) {
	var it models.BulkCreateRelationshipsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["skipInvalid"]; !present {
		asMap["skipInvalid"] = false
	}

	fieldsInOrder := [...]string{"relationships", "skipInvalid"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "relationships":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("relationships"))
			data, err := ec.unmarshalNCreateRelationshipInput2githubcomornerydnornicdbpkggraphqlmodelsCreateRelationshipInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Relationships = data
		case "skipInvalid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skipInvalid"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkipInvalid = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateNodeInput(ctx context.Context, obj any) (models.CreateNodeInput, error) {
	var it models.CreateNodeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["tier"]; !present {
		asMap["tier"] = "SEMANTIC"
	}

	fieldsInOrder := [...]string{"id", "labels", "properties", "tier", "embedding"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "properties":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "tier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			data, err := ec.unmarshalOMemoryTier2githubcomornerydnornicdbpkggraphqlmodelsMemoryTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tier = data
		case "embedding":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embedding"))
			data, err := ec.unmarshalOFloatArray2githubcomornerydnornicdbpkggraphqlmodelsFloatArray(ctx, v)
			if err != nil {
				return it, err
			}
			it.Embedding = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRelationshipInput(ctx context.Context, obj any) (models.CreateRelationshipInput, error) {
	var it models.CreateRelationshipInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "startNodeId", "endNodeId", "type", "properties"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "startNodeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startNodeId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartNodeID = data
		case "endNodeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endNodeId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndNodeID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "properties":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCypherInput(ctx context.Context, obj any) (models.CypherInput, error) {
	var it models.CypherInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"statement", "parameters", "timeoutMs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "statement":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statement"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statement = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		case "timeoutMs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeoutMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeoutMs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchOptions(ctx context.Context, obj any) (models.SearchOptions, error) {
	var it models.SearchOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 10
	}
	if _, present := asMap["offset"]; !present {
		asMap["offset"] = 0
	}
	if _, present := asMap["method"]; !present {
		asMap["method"] = "HYBRID"
	}
	if _, present := asMap["minScore"]; !present {
		asMap["minScore"] = 0.000000
	}
	if _, present := asMap["sortBy"]; !present {
		asMap["sortBy"] = "RELEVANCE"
	}
	if _, present := asMap["sortOrder"]; !present {
		asMap["sortOrder"] = "DESC"
	}
	if _, present := asMap["includeDecayed"]; !present {
		asMap["includeDecayed"] = false
	}
	if _, present := asMap["minDecayScore"]; !present {
		asMap["minDecayScore"] = 0.000000
	}

	fieldsInOrder := [...]string{"limit", "offset", "labels", "method", "minScore", "sortBy", "sortOrder", "includeDecayed", "minDecayScore", "propertyFilters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "method":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			data, err := ec.unmarshalOSearchMethod2githubcomornerydnornicdbpkggraphqlmodelsSearchMethod(ctx, v)
			if err != nil {
				return it, err
			}
			it.Method = data
		case "minScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minScore"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinScore = data
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalOSearchSortBy2githubcomornerydnornicdbpkggraphqlmodelsSearchSortBy(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "sortOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortOrder"))
			data, err := ec.unmarshalOSortOrder2githubcomornerydnornicdbpkggraphqlmodelsSortOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortOrder = data
		case "includeDecayed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDecayed"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeDecayed = data
		case "minDecayScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minDecayScore"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinDecayScore = data
		case "propertyFilters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertyFilters"))
			data, err := ec.unmarshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.PropertyFilters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateNodeInput(ctx context.Context, obj any) (models.UpdateNodeInput, error) {
	var it models.UpdateNodeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "labels", "properties", "removeProperties", "addLabels", "removeLabels", "embedding"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "properties":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "removeProperties":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeProperties"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveProperties = data
		case "addLabels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addLabels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddLabels = data
		case "removeLabels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeLabels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveLabels = data
		case "embedding":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embedding"))
			data, err := ec.unmarshalOFloatArray2githubcomornerydnornicdbpkggraphqlmodelsFloatArray(ctx, v)
			if err != nil {
				return it, err
			}
			it.Embedding = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRelationshipInput(ctx context.Context, obj any) (models.UpdateRelationshipInput, error) {
	var it models.UpdateRelationshipInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type", "properties", "removeProperties"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "properties":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "removeProperties":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeProperties"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveProperties = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var bulkCreateResultImplementors = []string{"BulkCreateResult"}

func (ec *executionContext) _BulkCreateResult(ctx context.Context, sel ast.SelectionSet, obj *models.BulkCreateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bulkCreateResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BulkCreateResult")
		case "created":
			out.Values[i] = ec._BulkCreateResult_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "skipped":
			out.Values[i] = ec._BulkCreateResult_skipped(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._BulkCreateResult_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bulkDeleteResultImplementors = []string{"BulkDeleteResult"}

func (ec *executionContext) _BulkDeleteResult(ctx context.Context, sel ast.SelectionSet, obj *models.BulkDeleteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bulkDeleteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BulkDeleteResult")
		case "deleted":
			out.Values[i] = ec._BulkDeleteResult_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "notFound":
			out.Values[i] = ec._BulkDeleteResult_notFound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cypherResultImplementors = []string{"CypherResult"}

func (ec *executionContext) _CypherResult(ctx context.Context, sel ast.SelectionSet, obj *models.CypherResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cypherResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CypherResult")
		case "columns":
			out.Values[i] = ec._CypherResult_columns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "rows":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CypherResult_rows(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rowCount":
			out.Values[i] = ec._CypherResult_rowCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stats":
			out.Values[i] = ec._CypherResult_stats(ctx, field, obj)
		case "executionTimeMs":
			out.Values[i] = ec._CypherResult_executionTimeMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cypherStatsImplementors = []string{"CypherStats"}

func (ec *executionContext) _CypherStats(ctx context.Context, sel ast.SelectionSet, obj *models.CypherStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cypherStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CypherStats")
		case "nodesCreated":
			out.Values[i] = ec._CypherStats_nodesCreated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodesDeleted":
			out.Values[i] = ec._CypherStats_nodesDeleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationshipsCreated":
			out.Values[i] = ec._CypherStats_relationshipsCreated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationshipsDeleted":
			out.Values[i] = ec._CypherStats_relationshipsDeleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "propertiesSet":
			out.Values[i] = ec._CypherStats_propertiesSet(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labelsAdded":
			out.Values[i] = ec._CypherStats_labelsAdded(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labelsRemoved":
			out.Values[i] = ec._CypherStats_labelsRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "containsUpdates":
			out.Values[i] = ec._CypherStats_containsUpdates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var databaseStatsImplementors = []string{"DatabaseStats"}

func (ec *executionContext) _DatabaseStats(ctx context.Context, sel ast.SelectionSet, obj *models.DatabaseStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, databaseStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatabaseStats")
		case "nodeCount":
			out.Values[i] = ec._DatabaseStats_nodeCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationshipCount":
			out.Values[i] = ec._DatabaseStats_relationshipCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._DatabaseStats_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationshipTypes":
			out.Values[i] = ec._DatabaseStats_relationshipTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "embeddedNodeCount":
			out.Values[i] = ec._DatabaseStats_embeddedNodeCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uptimeSeconds":
			out.Values[i] = ec._DatabaseStats_uptimeSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memoryUsageBytes":
			out.Values[i] = ec._DatabaseStats_memoryUsageBytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var decayResultImplementors = []string{"DecayResult"}

func (ec *executionContext) _DecayResult(ctx context.Context, sel ast.SelectionSet, obj *models.DecayResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, decayResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DecayResult")
		case "nodesProcessed":
			out.Values[i] = ec._DecayResult_nodesProcessed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodesDecayed":
			out.Values[i] = ec._DecayResult_nodesDecayed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "averageDecayScore":
			out.Values[i] = ec._DecayResult_averageDecayScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var embeddingStatusImplementors = []string{"EmbeddingStatus"}

func (ec *executionContext) _EmbeddingStatus(ctx context.Context, sel ast.SelectionSet, obj *models.EmbeddingStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, embeddingStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EmbeddingStatus")
		case "pending":
			out.Values[i] = ec._EmbeddingStatus_pending(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "embedded":
			out.Values[i] = ec._EmbeddingStatus_embedded(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._EmbeddingStatus_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workerRunning":
			out.Values[i] = ec._EmbeddingStatus_workerRunning(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var graphSchemaImplementors = []string{"GraphSchema"}

func (ec *executionContext) _GraphSchema(ctx context.Context, sel ast.SelectionSet, obj *models.GraphSchema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, graphSchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GraphSchema")
		case "nodeLabels":
			out.Values[i] = ec._GraphSchema_nodeLabels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationshipTypes":
			out.Values[i] = ec._GraphSchema_relationshipTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodePropertyKeys":
			out.Values[i] = ec._GraphSchema_nodePropertyKeys(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationshipPropertyKeys":
			out.Values[i] = ec._GraphSchema_relationshipPropertyKeys(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "constraints":
			out.Values[i] = ec._GraphSchema_constraints(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var labelStatsImplementors = []string{"LabelStats"}

func (ec *executionContext) _LabelStats(ctx context.Context, sel ast.SelectionSet, obj *models.LabelStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelStats")
		case "label":
			out.Values[i] = ec._LabelStats_label(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._LabelStats_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createNode":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createNode(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateNode":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateNode(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteNode":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteNode(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateNodes":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateNodes(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteNodes":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteNodes(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeNode":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_mergeNode(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createRelationship":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createRelationship(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateRelationship":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRelationship(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteRelationship":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteRelationship(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkCreateRelationships":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkCreateRelationships(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bulkDeleteRelationships":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bulkDeleteRelationships(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeRelationship":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_mergeRelationship(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "executeCypher":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_executeCypher(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerEmbedding":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_triggerEmbedding(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rebuildSearchIndex":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rebuildSearchIndex(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "runDecay":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_runDecay(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clearAll":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_clearAll(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nodeImplementors = []string{"Node"}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj *models.Node) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Node")
		case "id":
			out.Values[i] = ec._Node_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "internalId":
			out.Values[i] = ec._Node_internalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			out.Values[i] = ec._Node_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._Node_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Node_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Node_updatedAt(ctx, field, obj)
		case "decayScore":
			out.Values[i] = ec._Node_decayScore(ctx, field, obj)
		case "lastAccessed":
			out.Values[i] = ec._Node_lastAccessed(ctx, field, obj)
		case "accessCount":
			out.Values[i] = ec._Node_accessCount(ctx, field, obj)
		case "hasEmbedding":
			out.Values[i] = ec._Node_hasEmbedding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "embeddingDimensions":
			out.Values[i] = ec._Node_embeddingDimensions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "relationships":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Node_relationships(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "outgoing":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Node_outgoing(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "incoming":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Node_incoming(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "neighbors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Node_neighbors(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "similar":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Node_similar(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "allNodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allNodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodesByLabel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodesByLabel(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodeCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodeCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "relationship":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_relationship(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "allRelationships":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allRelationships(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "relationshipsByType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_relationshipsByType(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "relationshipsBetween":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_relationshipsBetween(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "relationshipCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_relationshipCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "search":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_search(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "similar":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_similar(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchByProperty":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchByProperty(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cypher":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cypher(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "stats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "schema":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_schema(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "labels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_labels(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "relationshipTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_relationshipTypes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "shortestPath":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_shortestPath(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "allPaths":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allPaths(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "neighborhood":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_neighborhood(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var relationshipImplementors = []string{"Relationship"}

func (ec *executionContext) _Relationship(ctx context.Context, sel ast.SelectionSet, obj *models.Relationship) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, relationshipImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Relationship")
		case "id":
			out.Values[i] = ec._Relationship_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "internalId":
			out.Values[i] = ec._Relationship_internalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Relationship_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startNode":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Relationship_startNode(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "endNode":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Relationship_endNode(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "properties":
			out.Values[i] = ec._Relationship_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Relationship_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Relationship_updatedAt(ctx, field, obj)
		case "confidence":
			out.Values[i] = ec._Relationship_confidence(ctx, field, obj)
		case "autoGenerated":
			out.Values[i] = ec._Relationship_autoGenerated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var relationshipTypeStatsImplementors = []string{"RelationshipTypeStats"}

func (ec *executionContext) _RelationshipTypeStats(ctx context.Context, sel ast.SelectionSet, obj *models.RelationshipTypeStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, relationshipTypeStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RelationshipTypeStats")
		case "type":
			out.Values[i] = ec._RelationshipTypeStats_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._RelationshipTypeStats_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var schemaConstraintImplementors = []string{"SchemaConstraint"}

func (ec *executionContext) _SchemaConstraint(ctx context.Context, sel ast.SelectionSet, obj *models.SchemaConstraint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, schemaConstraintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SchemaConstraint")
		case "name":
			out.Values[i] = ec._SchemaConstraint_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._SchemaConstraint_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "entityType":
			out.Values[i] = ec._SchemaConstraint_entityType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labelsOrTypes":
			out.Values[i] = ec._SchemaConstraint_labelsOrTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "properties":
			out.Values[i] = ec._SchemaConstraint_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchResponseImplementors = []string{"SearchResponse"}

func (ec *executionContext) _SearchResponse(ctx context.Context, sel ast.SelectionSet, obj *models.SearchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchResponse")
		case "results":
			out.Values[i] = ec._SearchResponse_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._SearchResponse_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "method":
			out.Values[i] = ec._SearchResponse_method(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "executionTimeMs":
			out.Values[i] = ec._SearchResponse_executionTimeMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vectorSearchUsed":
			out.Values[i] = ec._SearchResponse_vectorSearchUsed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bm25SearchUsed":
			out.Values[i] = ec._SearchResponse_bm25SearchUsed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchResultImplementors = []string{"SearchResult"}

func (ec *executionContext) _SearchResult(ctx context.Context, sel ast.SelectionSet, obj *models.SearchResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchResult")
		case "node":
			out.Values[i] = ec._SearchResult_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "score":
			out.Values[i] = ec._SearchResult_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rrfScore":
			out.Values[i] = ec._SearchResult_rrfScore(ctx, field, obj)
		case "vectorScore":
			out.Values[i] = ec._SearchResult_vectorScore(ctx, field, obj)
		case "bm25Score":
			out.Values[i] = ec._SearchResult_bm25Score(ctx, field, obj)
		case "vectorRank":
			out.Values[i] = ec._SearchResult_vectorRank(ctx, field, obj)
		case "bm25Rank":
			out.Values[i] = ec._SearchResult_bm25Rank(ctx, field, obj)
		case "foundBy":
			out.Values[i] = ec._SearchResult_foundBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var similarNodeImplementors = []string{"SimilarNode"}

func (ec *executionContext) _SimilarNode(ctx context.Context, sel ast.SelectionSet, obj *models.SimilarNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, similarNodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SimilarNode")
		case "node":
			out.Values[i] = ec._SimilarNode_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "similarity":
			out.Values[i] = ec._SimilarNode_similarity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subgraphImplementors = []string{"Subgraph"}

func (ec *executionContext) _Subgraph(ctx context.Context, sel ast.SelectionSet, obj *models.Subgraph) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subgraphImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Subgraph")
		case "nodes":
			out.Values[i] = ec._Subgraph_nodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relationships":
			out.Values[i] = ec._Subgraph_relationships(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		graphql.AddErrorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "nodeCreated":
		return ec._Subscription_nodeCreated(ctx, fields[0])
	case "nodeUpdated":
		return ec._Subscription_nodeUpdated(ctx, fields[0])
	case "nodeDeleted":
		return ec._Subscription_nodeDeleted(ctx, fields[0])
	case "relationshipCreated":
		return ec._Subscription_relationshipCreated(ctx, fields[0])
	case "relationshipUpdated":
		return ec._Subscription_relationshipUpdated(ctx, fields[0])
	case "relationshipDeleted":
		return ec._Subscription_relationshipDeleted(ctx, fields[0])
	case "searchStream":
		return ec._Subscription_searchStream(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBulkCreateNodesInput2githubcomornerydnornicdbpkggraphqlmodelsBulkCreateNodesInput(ctx context.Context, v any) (models.BulkCreateNodesInput, error) {
	res, err := ec.unmarshalInputBulkCreateNodesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBulkCreateRelationshipsInput2githubcomornerydnornicdbpkggraphqlmodelsBulkCreateRelationshipsInput(ctx context.Context, v any) (models.BulkCreateRelationshipsInput, error) {
	res, err := ec.unmarshalInputBulkCreateRelationshipsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBulkCreateResult2githubcomornerydnornicdbpkggraphqlmodelsBulkCreateResult(ctx context.Context, sel ast.SelectionSet, v models.BulkCreateResult) graphql.Marshaler {
	return ec._BulkCreateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNBulkCreateResult2githubcomornerydnornicdbpkggraphqlmodelsBulkCreateResult(ctx context.Context, sel ast.SelectionSet, v *models.BulkCreateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BulkCreateResult(ctx, sel, v)
}

func (ec *executionContext) marshalNBulkDeleteResult2githubcomornerydnornicdbpkggraphqlmodelsBulkDeleteResult(ctx context.Context, sel ast.SelectionSet, v models.BulkDeleteResult) graphql.Marshaler {
	return ec._BulkDeleteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNBulkDeleteResult2githubcomornerydnornicdbpkggraphqlmodelsBulkDeleteResult(ctx context.Context, sel ast.SelectionSet, v *models.BulkDeleteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BulkDeleteResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateNodeInput2githubcomornerydnornicdbpkggraphqlmodelsCreateNodeInput(ctx context.Context, v any) (models.CreateNodeInput, error) {
	res, err := ec.unmarshalInputCreateNodeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateNodeInput2githubcomornerydnornicdbpkggraphqlmodelsCreateNodeInput(ctx context.Context, v any) ([]*models.CreateNodeInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*models.CreateNodeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateNodeInput2githubcomornerydnornicdbpkggraphqlmodelsCreateNodeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateNodeInput2githubcomornerydnornicdbpkggraphqlmodelsCreateNodeInput(ctx context.Context, v any) (*models.CreateNodeInput, error) {
	res, err := ec.unmarshalInputCreateNodeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateRelationshipInput2githubcomornerydnornicdbpkggraphqlmodelsCreateRelationshipInput(ctx context.Context, v any) (models.CreateRelationshipInput, error) {
	res, err := ec.unmarshalInputCreateRelationshipInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateRelationshipInput2githubcomornerydnornicdbpkggraphqlmodelsCreateRelationshipInput(ctx context.Context, v any) ([]*models.CreateRelationshipInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*models.CreateRelationshipInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCreateRelationshipInput2githubcomornerydnornicdbpkggraphqlmodelsCreateRelationshipInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCreateRelationshipInput2githubcomornerydnornicdbpkggraphqlmodelsCreateRelationshipInput(ctx context.Context, v any) (*models.CreateRelationshipInput, error) {
	res, err := ec.unmarshalInputCreateRelationshipInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCypherInput2githubcomornerydnornicdbpkggraphqlmodelsCypherInput(ctx context.Context, v any) (models.CypherInput, error) {
	res, err := ec.unmarshalInputCypherInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCypherResult2githubcomornerydnornicdbpkggraphqlmodelsCypherResult(ctx context.Context, sel ast.SelectionSet, v models.CypherResult) graphql.Marshaler {
	return ec._CypherResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNCypherResult2githubcomornerydnornicdbpkggraphqlmodelsCypherResult(ctx context.Context, sel ast.SelectionSet, v *models.CypherResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CypherResult(ctx, sel, v)
}

func (ec *executionContext) marshalNDatabaseStats2githubcomornerydnornicdbpkggraphqlmodelsDatabaseStats(ctx context.Context, sel ast.SelectionSet, v models.DatabaseStats) graphql.Marshaler {
	return ec._DatabaseStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNDatabaseStats2githubcomornerydnornicdbpkggraphqlmodelsDatabaseStats(ctx context.Context, sel ast.SelectionSet, v *models.DatabaseStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DatabaseStats(ctx, sel, v)
}

func (ec *executionContext) marshalNDecayResult2githubcomornerydnornicdbpkggraphqlmodelsDecayResult(ctx context.Context, sel ast.SelectionSet, v models.DecayResult) graphql.Marshaler {
	return ec._DecayResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDecayResult2githubcomornerydnornicdbpkggraphqlmodelsDecayResult(ctx context.Context, sel ast.SelectionSet, v *models.DecayResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DecayResult(ctx, sel, v)
}

func (ec *executionContext) marshalNEmbeddingStatus2githubcomornerydnornicdbpkggraphqlmodelsEmbeddingStatus(ctx context.Context, sel ast.SelectionSet, v models.EmbeddingStatus) graphql.Marshaler {
	return ec._EmbeddingStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNEmbeddingStatus2githubcomornerydnornicdbpkggraphqlmodelsEmbeddingStatus(ctx context.Context, sel ast.SelectionSet, v *models.EmbeddingStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EmbeddingStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNGraphSchema2githubcomornerydnornicdbpkggraphqlmodelsGraphSchema(ctx context.Context, sel ast.SelectionSet, v models.GraphSchema) graphql.Marshaler {
	return ec._GraphSchema(ctx, sel, &v)
}

func (ec *executionContext) marshalNGraphSchema2githubcomornerydnornicdbpkggraphqlmodelsGraphSchema(ctx context.Context, sel ast.SelectionSet, v *models.GraphSchema) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GraphSchema(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx context.Context, v any) (models.JSON, error) {
	var res models.JSON
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx context.Context, sel ast.SelectionSet, v models.JSON) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx context.Context, v any) ([]models.JSON, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]models.JSON, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx context.Context, sel ast.SelectionSet, v []models.JSON) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx context.Context, v any) ([][]models.JSON, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([][]models.JSON, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx context.Context, sel ast.SelectionSet, v [][]models.JSON) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLabelStats2githubcomornerydnornicdbpkggraphqlmodelsLabelStats(ctx context.Context, sel ast.SelectionSet, v []*models.LabelStats) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLabelStats2githubcomornerydnornicdbpkggraphqlmodelsLabelStats(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLabelStats2githubcomornerydnornicdbpkggraphqlmodelsLabelStats(ctx context.Context, sel ast.SelectionSet, v *models.LabelStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LabelStats(ctx, sel, v)
}

func (ec *executionContext) marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx context.Context, sel ast.SelectionSet, v models.Node) graphql.Marshaler {
	return ec._Node(ctx, sel, &v)
}

func (ec *executionContext) marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx context.Context, sel ast.SelectionSet, v []models.Node) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx context.Context, sel ast.SelectionSet, v [][]models.Node) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx context.Context, sel ast.SelectionSet, v []*models.Node) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx context.Context, sel ast.SelectionSet, v *models.Node) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship(ctx context.Context, sel ast.SelectionSet, v models.Relationship) graphql.Marshaler {
	return ec._Relationship(ctx, sel, &v)
}

func (ec *executionContext) marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship(ctx context.Context, sel ast.SelectionSet, v []models.Relationship) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship(ctx context.Context, sel ast.SelectionSet, v []*models.Relationship) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship(ctx context.Context, sel ast.SelectionSet, v *models.Relationship) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Relationship(ctx, sel, v)
}

func (ec *executionContext) marshalNRelationshipTypeStats2githubcomornerydnornicdbpkggraphqlmodelsRelationshipTypeStats(ctx context.Context, sel ast.SelectionSet, v []*models.RelationshipTypeStats) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRelationshipTypeStats2githubcomornerydnornicdbpkggraphqlmodelsRelationshipTypeStats(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRelationshipTypeStats2githubcomornerydnornicdbpkggraphqlmodelsRelationshipTypeStats(ctx context.Context, sel ast.SelectionSet, v *models.RelationshipTypeStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RelationshipTypeStats(ctx, sel, v)
}

func (ec *executionContext) marshalNSchemaConstraint2githubcomornerydnornicdbpkggraphqlmodelsSchemaConstraint(ctx context.Context, sel ast.SelectionSet, v []*models.SchemaConstraint) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSchemaConstraint2githubcomornerydnornicdbpkggraphqlmodelsSchemaConstraint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSchemaConstraint2githubcomornerydnornicdbpkggraphqlmodelsSchemaConstraint(ctx context.Context, sel ast.SelectionSet, v *models.SchemaConstraint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SchemaConstraint(ctx, sel, v)
}

func (ec *executionContext) marshalNSearchResponse2githubcomornerydnornicdbpkggraphqlmodelsSearchResponse(ctx context.Context, sel ast.SelectionSet, v models.SearchResponse) graphql.Marshaler {
	return ec._SearchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchResponse2githubcomornerydnornicdbpkggraphqlmodelsSearchResponse(ctx context.Context, sel ast.SelectionSet, v *models.SearchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSearchResult2githubcomornerydnornicdbpkggraphqlmodelsSearchResult(ctx context.Context, sel ast.SelectionSet, v models.SearchResult) graphql.Marshaler {
	return ec._SearchResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchResult2githubcomornerydnornicdbpkggraphqlmodelsSearchResult(ctx context.Context, sel ast.SelectionSet, v []*models.SearchResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSearchResult2githubcomornerydnornicdbpkggraphqlmodelsSearchResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSearchResult2githubcomornerydnornicdbpkggraphqlmodelsSearchResult(ctx context.Context, sel ast.SelectionSet, v *models.SearchResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchResult(ctx, sel, v)
}

func (ec *executionContext) marshalNSimilarNode2githubcomornerydnornicdbpkggraphqlmodelsSimilarNode(ctx context.Context, sel ast.SelectionSet, v models.SimilarNode) graphql.Marshaler {
	return ec._SimilarNode(ctx, sel, &v)
}

func (ec *executionContext) marshalNSimilarNode2githubcomornerydnornicdbpkggraphqlmodelsSimilarNode(ctx context.Context, sel ast.SelectionSet, v []models.SimilarNode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSimilarNode2githubcomornerydnornicdbpkggraphqlmodelsSimilarNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSubgraph2githubcomornerydnornicdbpkggraphqlmodelsSubgraph(ctx context.Context, sel ast.SelectionSet, v models.Subgraph) graphql.Marshaler {
	return ec._Subgraph(ctx, sel, &v)
}

func (ec *executionContext) marshalNSubgraph2githubcomornerydnornicdbpkggraphqlmodelsSubgraph(ctx context.Context, sel ast.SelectionSet, v *models.Subgraph) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Subgraph(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateNodeInput2githubcomornerydnornicdbpkggraphqlmodelsUpdateNodeInput(ctx context.Context, v any) (models.UpdateNodeInput, error) {
	res, err := ec.unmarshalInputUpdateNodeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateRelationshipInput2githubcomornerydnornicdbpkggraphqlmodelsUpdateRelationshipInput(ctx context.Context, v any) (models.UpdateRelationshipInput, error) {
	res, err := ec.unmarshalInputUpdateRelationshipInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCypherStats2githubcomornerydnornicdbpkggraphqlmodelsCypherStats(ctx context.Context, sel ast.SelectionSet, v *models.CypherStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CypherStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalODateTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloatArray2githubcomornerydnornicdbpkggraphqlmodelsFloatArray(ctx context.Context, v any) (models.FloatArray, error) {
	if v == nil {
		return nil, nil
	}
	var res models.FloatArray
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloatArray2githubcomornerydnornicdbpkggraphqlmodelsFloatArray(ctx context.Context, sel ast.SelectionSet, v models.FloatArray) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx context.Context, v any) (models.JSON, error) {
	if v == nil {
		return nil, nil
	}
	var res models.JSON
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2githubcomornerydnornicdbpkggraphqlmodelsJSON(ctx context.Context, sel ast.SelectionSet, v models.JSON) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMemoryTier2githubcomornerydnornicdbpkggraphqlmodelsMemoryTier(ctx context.Context, v any) (*models.MemoryTier, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.MemoryTier)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMemoryTier2githubcomornerydnornicdbpkggraphqlmodelsMemoryTier(ctx context.Context, sel ast.SelectionSet, v *models.MemoryTier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalONode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx context.Context, sel ast.SelectionSet, v []models.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONode2githubcomornerydnornicdbpkggraphqlmodelsNode(ctx context.Context, sel ast.SelectionSet, v *models.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalORelationship2githubcomornerydnornicdbpkggraphqlmodelsRelationship(ctx context.Context, sel ast.SelectionSet, v *models.Relationship) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Relationship(ctx, sel, v)
}

func (ec *executionContext) unmarshalORelationshipDirection2githubcomornerydnornicdbpkggraphqlmodelsRelationshipDirection(ctx context.Context, v any) (*models.RelationshipDirection, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.RelationshipDirection)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORelationshipDirection2githubcomornerydnornicdbpkggraphqlmodelsRelationshipDirection(ctx context.Context, sel ast.SelectionSet, v *models.RelationshipDirection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSearchMethod2githubcomornerydnornicdbpkggraphqlmodelsSearchMethod(ctx context.Context, v any) (*models.SearchMethod, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.SearchMethod)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchMethod2githubcomornerydnornicdbpkggraphqlmodelsSearchMethod(ctx context.Context, sel ast.SelectionSet, v *models.SearchMethod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSearchOptions2githubcomornerydnornicdbpkggraphqlmodelsSearchOptions(ctx context.Context, v any) (*models.SearchOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchSortBy2githubcomornerydnornicdbpkggraphqlmodelsSearchSortBy(ctx context.Context, v any) (*models.SearchSortBy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.SearchSortBy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchSortBy2githubcomornerydnornicdbpkggraphqlmodelsSearchSortBy(ctx context.Context, sel ast.SelectionSet, v *models.SearchSortBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSortOrder2githubcomornerydnornicdbpkggraphqlmodelsSortOrder(ctx context.Context, v any) (*models.SortOrder, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.SortOrder)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSortOrder2githubcomornerydnornicdbpkggraphqlmodelsSortOrder(ctx context.Context, sel ast.SelectionSet, v *models.SortOrder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
